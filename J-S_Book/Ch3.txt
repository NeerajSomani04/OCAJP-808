Core Java APIs:-  API (Application Programming Interface)
Interface:- Consist of classes and interfaces that provide some functionality or service.

Few important fundamental Classes -->
String 
StringBuilder
ArrayList

<-- String -->
  Concatenation --> 3 rules 
    1. If both operands are numeric, + means numeric addition.
    2. If either operand is a String, + means concatenation.
    3. The expression is evaluated left to right.

  Immutability -> (unchangable)
    String objects can't be changed once created.

  The String Pool --> is a location in the Java virtual machine (JVM)  that collects all these strings.
    It contains literal values.
    
  Important String Methods --> 
    length() --> returns the number of characters in the String.
    charAt() --> lets you query the string using index value, 
    indexOf() --> indexOf can work with an individual character or a whole String as input. 
        indexOf() returns –1 when no match is found.
      The method signatures are as follows:
        int indexOf(char ch)
        int indexOf(char ch, index fromIndex)
        int indexOf(String str)
        int indexOf(String str, index fromIndex)
     substring() --> returns parts of the string.
      The method signatures are as follows:
        int substring(int beginIndex)
        int substring(int beginIndex, int endIndex) // endIndex is non-inclusive
    toLowerCase() and toUpperCase() --> converts characters to uppercase/lowercase in the returned string.
      String toLowerCase(String str)
      String toUpperCase(String str)
  equals() and equalsIgnoreCase() --> checks whether two String objects contain exactly the same characters in the same order.
    boolean equals(String str)
    boolean equalsIgnoreCase(String str)
  startsWith() and endsWith() --> methods look at whether the provided value matches part of the String.
    boolean startsWith(String prefix)
    boolean endsWith(String suffix)
  contains() --> method also looks for matches in the String. the match can be anywhere in the String. 
    boolean contains(String str)
  replace() --> method does a simple search and replace on the string.
    String replace(char oldChar, char newChar) // notice here we can pass char values
    String replace(CharSequence oldChar, CharSequence newChar) // notice here we can pass String values
  trim() --> method removes whitespace from the beginning and end of a String.
     example -->
        System.out.println("abc".trim()); // abc
        System.out.println("\t a b c\n".trim()); // a b c
  
<-- StringBuilder -->  
 This class creates a String without storing all those interim String values. Unlike the String class, StringBuilder is mutable.
  Chaining --> the StringBuilder changes its own state and returns a reference to itself!
  
Creating a StringBuilder
There are three ways to construct a StringBuilder:
StringBuilder sb1 = new StringBuilder(); // creating sb1 reference to empty StringBuilder object 
StringBuilder sb2 = new StringBuilder("animal"); // creating sb2 reference to StringBuilder object that contains "animal"
StringBuilder sb3 = new StringBuilder(10); //creating sb3 reference to empty StringBuilder object having initial capacity of storing 10 charachters. 
  Size vs Capacity --> Size is the number of characters currently in the sequence, and capacity is the number of characters the sequence can currently hold.
    important --> Size <= capacity or capacity >= size

StringBuilder Methods -->
  charAt(), indexOf(), length(), and substring()
  All above methods works exactly same as described in String class. Notice that substring() returns a String rather than a StringBuilder. Hence when used with StringBuilder, doesn't directly change StringBuilder object.
 append() --> it adds the parameter to the StringBuilder and returns a reference to the current StringBuilder.
  One of the method signatures is as follows:
    StringBuilder append(String str) // Notice there are around 10 similar method signature for different datatypes as parameter.
insert() --> method adds characters to the StringBuilder at the requested index and returns a reference to the current StringBuilder.    Just like append(), there are lots of  method signatures for different types. Here’s one:
  StringBuilder insert(int offset, String str)
delete() and deleteCharAt() --> 
  The delete() method , It removes characters from the sequence and returns a reference to the current StringBuilder. 
  The deleteCharAt() method to delete only one character. 
    The method signatures are as follows:
        StringBuilder delete(int start, int end)
        StringBuilder deleteCharAt(int index) 
reverse() --> it reverses the characters in the sequences and returns a reference to the current StringBuilder.
  The method signature : StringBuilder reverse()
toString() --> converts a StringBuilder into a String.
  
StringBuilder vs. StringBuffer -->
  StringBuilder was added to Java in Java 5. In older version / code, you will see StringBuffer used for this purpose.
  StringBuffer does the same thing but more slowly because it is thread safe.
  
Understanding Equality -->
equals() method to check the values inside the String rather than the String itself.
If you call equals() on two StringBuilder instances, it will check reference equality.
If a class doesn’t have an equals method, Java determines whether the references point to the same object—which is exactly what == does.
"==" this checks whether two references pointing to same object or not.

Java Arrays -->
  An array is an area of memory on the heap with space for a designated number of elements. An array is an ordered list. It can contain duplicates.
  String Array --> when dealing with characters specifically.
  StringBuilder Array --> implemented so that, the array object is replaced with a new bigger array object when it runs out of space to store all the characters.
  Important --> big difference is that an array can be of any other Java type.
  
Creating an Array of Primitives -->
  int[] numbers1 = new int[3]; --> It specifi es the type of the array (int) and the size (3). The brackets tell you this is an array.
  Another way to create an array is to specify all the elements it should start out with:
    int[] numbers2 = new int[] {42, 55, 99};
  or int[] numbers2 = {42, 55, 99};
  
  below are 4 different valid ways for creating Array -->
  int[] numAnimals;
  int [] numAnimals2; // adding space in between int and []
  int numAnimals3[];
  int numAnimals4 []; // adding space in between reference variable and []
  
  Multiple “Arrays” in Declarations -->
    int[] ids, types; // creates two array variables of type int
    int ids[], types; // creates one array variable of type int and one regular variable of type int
    
Creating an Array with Reference Variables -->
  As per below code we have created "alias" array from "bugs" array. where "alias" and "bugs" both are referece variable of String type array. 
  Below is sample code -->
      public class ArrayType {
      public static void main(String args[]) {
      String [] bugs = { "cricket", "beetle", "ladybug" };
      String [] alias = bugs;
      System.out.println(bugs.equals(alias)); // true
      System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
      } }

Using an Array --> Example 
  4: String[] mammals = {"monkey", "chimp", "donkey"};
  5: System.out.println(mammals.length); // 3
  6: System.out.println(mammals[0]); // monkey
  7: System.out.println(mammals[1]); // chimp
  8: System.out.println(mammals[2]); // donkey
  
Sorting -->
  This requires an import statement to inport sort method of Array class.
    import java.util.* // import whole package including Arrays
    import java.util.Arrays; // import just Arrays

using int type -->
  int[] numbers = { 6, 9, 1 };
  Arrays.sort(numbers);
  for (int i = 0; i < numbers.length; i++)
  L System.out.print (numbers[i] + " ");
    The result is 1 6 9, Notice that we had to loop through the output to print the values in the array. Just printing the array variable directly would give the annoying hash of [I@2bd9c3e7.

using String type -->    
    String[] strings = { "10", "9", "100" };
    Arrays.sort(strings);
    for (String string : strings)
    System.out.print(string + " ");
    
    This time the result might not be what you expect. This code outputs 10 100 9. The problem is that String sorts in alphabetic order, and 1 sorts before 9. (Numbers sort before letters and uppercase sorts before lowercase, in case you were wondering.)
    
    
Searching -->
  Three rules for binary search -->
    1. Target element found in sorted array --> Index of match
    2. Target element not found in sorted array --> Negative value showing one smaller than the negative of index, where a match needs to be inserted to preserve sorted order.
    3. Unsorted array -->  A surprise—this result isn’t predictable
  
  example for sorted array:
    3: int[] numbers = {2,4,6,8};
    4: System.out.println(Arrays.binarySearch(numbers, 2)); // 0
    5: System.out.println(Arrays.binarySearch(numbers, 4)); // 1
    6: System.out.println(Arrays.binarySearch(numbers, 1)); // -1
    7: System.out.println(Arrays.binarySearch(numbers, 3)); // -2
    8: System.out.println(Arrays.binarySearch(numbers, 9)); // -5
    
  example for unsorted array: 
    5: int numbers = new int[] {3,2,1};
    6: System.out.println(Arrays.binarySearch(numbers, 2)); // unpredictable output.
    7: System.out.println(Arrays.binarySearch(numbers, 3)); // unpredictable output.
    
    Note for Exam --> As soon as you see the array isn’t sorted, look for an answer choice about unpredictable output.
    
Varargs --> (variable arguments)
  Below are few valid example for declaring Array in method and how to use Array methods within method defination.
    public static void main(String[] args)
    public static void main(String args[])
    public static void main(String... args) // varargs

Multidimensional Arrays -->
  Arrays are objects, and of course array components can be objects. arrays can hold other arrays.
  few example of Multidimensional Array declaration :
    int[][] vars1; // 2D array
    int vars2 [][]; // 2D array
    int[] vars3[]; // 2D array
    int[] vars4 [], space [][]; // a 2D AND a 3D array

ArrayList -->
  ArrayList can change size at runtime as needed.
  ArrayList is an ordered sequence that allows duplicates.
    ArrayList also requires import class:
    import java.util.* // import whole package including ArrayList
    import java.util.ArrayList; // import just ArrayList

three ways to create an ArrayList: These works today as well but defined before java 5
ArrayList list1 = new ArrayList();
ArrayList list2 = new ArrayList(10);
ArrayList list3 = new ArrayList(list2);

two other ways to create an ArrayList:
ArrayList<String> list4 = new ArrayList<String>(); // this introduced starting java 5
ArrayList<String> list5 = new ArrayList<>(); // this introduced starting java 7

**ArrayList implements an interface called List.
List<String> list6 = new ArrayList<>();
ArrayList<String> list7 = new List<>(); // DOES NOT COMPILE // reason is that List is an interface and interfaces can’t be instantiated.

Using an ArrayList -->
  you will see something new in the method signatures: a “class” named E. In generics this mean “any class that this array can hold.”
  If you didn’t specify a type when creating the ArrayList, E means Object. Otherwise, it means the class you put between < and >.

add() methods --> insert a new value in the ArrayList
  boolean add(E element) // means it can hold “any class that this array can hold.”
  void add(int index, E element) // means need to provide index number and any object class
  
  example -->
    4: List<String> birds = new ArrayList<>();
    5: birds.add("hawk"); // [hawk]
    6: birds.add(1, "robin"); // [hawk, robin]
    7: birds.add(0, "blue jay"); // [blue jay, hawk, robin]
    8: birds.add(1, "cardinal"); // [blue jay, cardinal, hawk, robin]
    9: System.out.println(birds); // [blue jay, cardinal, hawk, robin]

remove() methods --> remove the fi rst matching value in the ArrayList or remove the element at a specifi ed index. 
  boolean remove(Object object) // this tells us whether a match was removed (true or false)
  E remove(int index) // this tells us the element that actually got removed
     Example -->
      3: List<String> birds = new ArrayList<>();
      4: birds.add("hawk"); // [hawk]
      5: birds.add("hawk"); // [hawk, hawk]
      6: System.out.println(birds.remove("cardinal")); // prints false
      7: System.out.println(birds.remove("hawk")); // prints true
      8: System.out.println(birds.remove(0)); // prints hawk
      9: System.out.println(birds); // []
      
set() method --> changes one of the elements of the ArrayList without changing the size.
  E set(int index, E newElement) // The E return type is the element that got replaced.
  Example -->
    15: List<String> birds = new ArrayList<>();
    16: birds.add("hawk"); // [hawk]
    17: System.out.println(birds.size()); // 1
    18: birds.set(0, "robin"); // [robin]
    19: System.out.println(birds.size()); // 1
    20: birds.set(1, "robin"); // IndexOutOfBoundsException

isEmpty() and size() methods --> look at how many of the slots are in use.
  boolean isEmpty()
  int size()
  Example --> 
      System.out.println(birds.isEmpty()); // true
      System.out.println(birds.size()); // 0
      birds.add("hawk"); // [hawk]
      birds.add("hawk"); // [hawk, hawk]
      System.out.println(birds.isEmpty()); // false
      System.out.println(birds.size()); // 2

clear() method --> provides an easy way to discard all elements of the ArrayList.
    void clear() 
      example -->
        List<String> birds = new ArrayList<>();
        birds.add("hawk"); // [hawk]
        birds.add("hawk"); // [hawk, hawk]
        System.out.println(birds.isEmpty()); // false
        System.out.println(birds.size()); // 2
        birds.clear(); // []
        System.out.println(birds.isEmpty()); // true
        System.out.println(birds.size()); // 0

contains() method --> checks whether a certain value is in the ArrayList. This method calls equals() on each element of the ArrayList to see whether there are any matches.
  boolean contains(Object object)
  example -->
    List<String> birds = new ArrayList<>();
    birds.add("hawk"); // [hawk]
    System.out.println(birds.contains("hawk")); // true
    System.out.println(birds.contains("robin")); // false

equals() method --> to compare two lists,  if they contain the same elements in the same order.
  boolean equals(Object object)
  exmaple -->
      31: List<String> one = new ArrayList<>();
      32: List<String> two = new ArrayList<>();
      33: System.out.println(one.equals(two)); // true
      34: one.add("a"); // [a]
      35: System.out.println(one.equals(two)); // false
      36: two.add("a"); // [a]
      37: System.out.println(one.equals(two)); // true
      38: one.add("b"); // [a,b]
      39: two.add(0, "b"); // [b,a]
      40: System.out.println(one.equals(two)); // false
     
Wrapper Classes --> This is helpful when we need to store any value (means primitive type) other than String type in Array or ArrayList.
  wrapper class is an object type that corresponds to the primitive type.
  
      Primitive type -- Wrapper class -- Example of constructing
      boolean -- Boolean -- new Boolean(true)
      byte -- Byte -- new Byte((byte) 1)
      short -- Short -- new Short((short) 1)
      int -- Integer -- new Integer(1)
      long -- Long -- new Long(1)
      float -- Float -- new Float(1.0)
      double -- Double -- new Double(1.0)
      char -- Character -- new Character('c')
      
   Wrapper classes methods -->
      a method that converts back to a primitive type
      methods for converting a String to a primitive or wrapper class
          The parse methods, such as parseInt(), return a primitive
          The valueOf() method returns a wrapper class
      **// need to understand with example what is the need for converting these values to primitve and wrapper class.
      
    example --> 
      int primitive = Integer.parseInt("123"); // converts a String to an int primitive
      Integer wrapper = Integer.valueOf("123"); // converts a String to an Integer wrapper class.
    
    If the String passed in is not valid for the given type, Java throws an exception. In these examples, letters and dots are not valid for an integer value:
    int bad1 = Integer.parseInt("a"); // throws NumberFormatException
    Integer bad2 = Integer.valueOf("123.45"); // throws NumberFormatException


Autoboxing --> just type the primitive value and Java will convert it to the relevant wrapper class for you.
    Example -->
      4: List<Double> weights = new ArrayList<>();
      5: weights.add(50.5); // [50.5] // autoboxes the double primitive into a Double object
      6: weights.add(new Double(60)); // [50.5, 60.0] // still write code the long way and pass in a wrapper object
      7: weights.remove(50.5); // [60.0] // autoboxes into the wrapper object and passes it to remove().
      8: double first = weights.get(0); // 60.0 // retrieves the Double and unboxes it into a double primitive
      
      Note --> if you try to unbox a null, you will get NullPointerException
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null);
      5: int h = heights.get(0); // NullPointerException

**//While using different methods need to understand which method looks for index value and which looks for actual data value.

Converting Between array and List (ArrayList) -->
  1) turning an ArrayList into an array: 
        this will convert an Arraylist into an Array of same size at the time of conversion. Array size can't be chnaged after that.
        Example:- 
          3: List<String> list = new ArrayList<>();
          4: list.add("hawk");
          Understanding an ArrayList 137
          5: list.add("robin");
          6: Object[] objectArray = list.toArray();
          7: System.out.println(objectArray.length); // 2
          8: String[] stringArray = list.toArray(new String[0]);
          9: System.out.println(stringArray.length); // 2
  2) turning an array into an List: 
        this will convert a fixed size array into fixed size List at the time of conversion. As we know we can't change array size once created but list can grow and Shrink. In this case List also can't chnages its size and hence known as Backed-List. 
        The original array and created array backed List are linked. When a change is made to one, it is available in the other. Although, chnage here means updating values, not changing the size. Chnaging the size will through exception.
        Example:-
          20: String[] array = { "hawk", "robin" }; // [hawk, robin]
          21: List<String> list = Arrays.asList(array); // returns fixed size list
          22: System.out.println(list.size()); // 2
          23: list.set(1, "test"); // [hawk, test]
          24: array[0] = "new"; // [new, test]
          25: for (String b : array) System.out.print(b + " "); // new test
          26: list.remove(1); // throws UnsupportedOperation Exception
          
methods of Arraylist -->
asList() method --> takes varargs, which let you pass in an array or just type out the String values.
  List<String> list = Arrays.asList("one", "two");
        
Sort() method --> Sorting an ArrayList is very similar to sorting an array. You just use a different helper class:
    example-->
        List<Integer> numbers = new ArrayList<>();
        numbers.add(99);
        numbers.add(5);
        numbers.add(81);
        Collections.sort(numbers); // Collections is the helper class
        System.out.println(numbers); [5, 81, 99]
        
Working with Dates and Times -->
  import java.time.*; // import time classes 
  LocalDate --> Contains just a date—no time and no time zone.
    LocalDate date1 = LocalDate.of(2015, Month.JANUARY, 20);
    LocalDate date2 = LocalDate.of(2015, 1, 20);
    ---LocalDateTime can use below methods----
      plusYears/minusYears 
      plusMonths/minusMonths 
      plusWeeks/minusWeeks 
      plusDays/minusDays
    
  LocalTime --> Contains just a time—no date and no time zone.
    LocalTime time1 = LocalTime.of(6, 15); // hour and minute
    LocalTime time2 = LocalTime.of(6, 15, 30); // + seconds
    LocalTime time3 = LocalTime.of(6, 15, 30, 200); // + nanoseconds
      ---LocalTime can use below methods---- 
      plusHours/minusHours 
      plusMinutes/minusMinutes 
      plusSeconds/minusSeconds
      plusNanos/minusNanos
      
  LocalDateTime --> Contains both a date and time but no time zone.
      public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
      public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
      public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
      public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
      public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
      public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
      public static LocalDateTime of(LocalDate date, LocalTime)
  
      ---LocalDateTime can use below methods----
      plusYears/minusYears 
      plusMonths/minusMonths 
      plusWeeks/minusWeeks 
      plusDays/minusDays 
      plusHours/minusHours 
      plusMinutes/minusMinutes 
      plusSeconds/minusSeconds
      plusNanos/minusNanos
  
  Below package needs to be imported before use:
  import java.time.*; // import time classes
      Tricks to remember -->
        You are not allowed to construct a date or time object directly. There is no constructor for Date and Time objects.
          LocalDate d = new LocalDate(); // DOES NOT COMPILE
        The date and time classes are immutable, just like String was. Means, remember to assign the results of these methods to a reference variable, so they are not lost because of Garbage Collector. 
   
   
   ---- Working with Periods ---
   
