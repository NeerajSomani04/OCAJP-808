chapter 4 - Methods and Encapsulation

Method signature and its components -->
  Access Modifiers --> in order from most restritive to least restrictive
    private --> Only accessible within the same class. The method can only be called from within the same class.
    Default (Package Private) Access --> can access in same package. The method can only be called from classes in the same package. There is no "default" keyword and hence we don't need to specify this in method declaration.
    protected --> The method can only be called from classes in the same package or subclasses (means, can be called from same package or different package). (page 178, 179 very important). Table on page 180.
      Subclasses means those classes which extends other parent class and become child class.  
    public --> The method can be called from any class.
 
  Optional Specifiers --> you can have zero or more specifiers in a method declaration.
    static --> Used for class methods. Static methods don’t require an instance of the class. They are shared among all users of the class.
    abstract --> Used when not providing a method body.
    final --> Used when a method is not allowed to be overridden by a subclass.
    synchronized, native, strictfp  --> not in OCA exam.

  Return Type --> a method must have a return type. If no value is returned, the return type is void. You cannot omit the return type.
    return type such as String or int --> return statement must include the primitive or object to be returned.
    void return type --> method body can have return statement with no value returned or omit the return statement entirely.
 
 Method Name --> contain letters, numbers, $, or _. Also, the first character is not allowed to be a number and reserved words are not allowed.
  
  Parameter List --> is required and it doesn’t have to contain any parameters.
      multiple parameters, you separate them with a comma.
 
 Optional Exception List --> it is an optional and method can specify exception in-case something go wrong and Can handle them.
  can specify multiple exception seperated by comma.

 Method Body --> is simply a code block. It has braces that contain zero or more Java statements. This is required.

**** very imp **** 
Working with Varargs --> vararg parameter (variable argument) as if it is an array.
      A vararg parameter must be the last element in a method’s parameter list. 
      only allowed to have one vararg parameter per method.
      When calling a method with a vararg parameter, you can pass in an array, or you can list the elements of the array and let Java create it for you.
      You can even omit the vararg values in the method call and Java will create an array of length zero for you.
      it is still possible to pass null explicitly to varargs. Although, Java might throw null exception if you try to perform some operation on this null value array.
      

    Designing Static Methods and Fields --> 
      Static methods don’t require an instance of the class. They are shared among all users of the class.
      as being a member of the single class object that exist independently of any instances of that class.
      instance variables --> Each class has a copy of the instance variables.
      instance methods --> There is only one copy of the code for the instance methods. it can be called as many times as needed.
                           However, Each call gets space on the stack for method parameters and local variables.
                           Remember that only data gets its “own copy.” There is no need to duplicate copies of the code itself.
      
      static methods --> 
        The main() method is a static method. That means you can call it by the classname.
        In addition to main() methods, static methods have two main purposes:
          --> For utility or helper methods that don’t require any object state. Since there is no need to access instance variables, having static methods eliminates the need for the caller to instantiate the object just to call the method.
          --> For state that is shared by all instances of a class, like a counter. All instances must share the same state. Methods that merely use that state should be static as well.
      
      
     Calling a Static Variable or Method -->
        just put the classname before the method or variable and you are done. you don't need to create an instance of the class to call static member of the class.
        For example:
              System.out.println(Koala.count);
              Koala.main(new String[0]);
      one rule that is trickier:-
        You can use an instance of the object to call a static method. The compiler checks for the type of the reference and uses that instead of the object. Example:
          5: Koala k = new Koala();
          6: System.out.println(k.count); // k is a Koala reference type
          7: k = null;
          8: System.out.println(k.count); // k is still a Koala
      // Java doesn’t care that k happens to be null. Since we are looking for a static method or variable. for java, k is still Koala reference type.
      // Remember to look at the reference type for a variable when you see a static method or variable.
      Static variable, means pointing same variable even if it is called by different objects references. (top 7 lines of page 183)
      
   Static vs Instance --> *************(very imp for exam)*********** (page 183)
      A static member cannot call an instance member. since static doesn’t require any instances of the class to be around.
      A static method or instance method can call a static method because static methods don’t require an object to use. 
      An instance method can call another instance method on the same class without using a reference variable, because instance methods do require an object. 
      Instance member can call static member without classname or reference variable, if its calling within same class.
   
   ---- Static Variables -->
    Some static variables are meant to change as the program runs. Means, value of same variable change as the program runs.
    Other static variables are meant to never change during the program. This type of variable is known as a constant. final modifier is used for this.
    We are allowed to call methods on reference variables.
      
  ----- Static Initialization -->
    --> static initialization block, is the block with curly braces {} that contain definition and initial assignment for all static variables.
    --> define static variable with keyword "static".
    --> you can assign a value to static variable while defining it or in the static initialization block.
    --> if "final" keyword is used with "static", then reassignment of value not allowed.
    --> Defining a static variable and not assigning any value to it is not allowed. Code will not compile.
    
 ---- Static Imports --->
  --> Static imports are for importing static members of classes. (always remember members of class means methods / variables)
      example:
      import static java.util.Arrays.asList; // static import
   --> The compiler will complain if you try to explicitly do a static import of two methods with the same name or two static variables with the same name. In such case we use class name with method name while using in code.
 
 ----- Passing Data Among Methods ---> Java is a “pass-by-value” language (page 190 - 191)
      --> methods on the parameters --> means, passing value of parameters to methods.
          example:-- String name = "Webby";
                     speak(name);
     --> method on the StringBuilder passed into the method: --> means passing value to inbuild method of StringBuilder
          example:- // In below example both name and s pointing to same StringBuilder object.
                    StringBuilder name = new StringBuilder();
                    speak(name);
                    public static void speak(StringBuilder s) {
                    s.append("Webby");
                    }
  
      --> Another trick to remember --> (page 191) ** very imp
            If result of method (returned value from method) is not stored in variable, it is being ignored by Java.
            But if it is stored in variable then Java uses that and doesn't ignore it.
            
----------- Overloading Methods --> different method signatures with the same name but different type parameters. This means there can be different access modifiers, specifiers (like static), return types, and exception lists.
      -- another tricky thing ---> Overloading and Varargs ----
        Java treats "varargs" as if they were an array. Hence, below 2 methods are same, which brings compile error for 2nd.
          public void fly(int[] lengths) { }
          public void fly(int... lengths) { } // DOES NOT COMPILE
      Although, it is also important to understand how they are not the same
      example -->
        fly(new int[] { 1, 2, 3 }); //either method can be called using this statement
        fly(1, 2, 3); // However, you can only call the varargs version with stand-alone parameters like this. This is important to understand regarding varargs.
    
 ---- Autoboxing --> Java will convert a primitive (int) to an object (Integer) to add it to an ArrayList through the wonders of autoboxing.
    --> If both version of method is available then java will give preference to primitive type method and will not bother to do extra work of outoboxing. When the primitive  (int) version isn't present, it will autobox.
        
    --> Hence, we can say Java calls the most specific method it can.
    In eralier verion of java 1.4 or older, Autoboxing and varargs doesn't exists. Hence, older code has to still work.
      Due to this reason there are few rules which Java uses to choose the right overloaded method.
      Rule --> Example of what will be chosen for glide(1,2)
      Exact match by type --> public String glide(int i, int j) {}
      Larger primitive type -->  public String glide(long i, long j) {}
      Autoboxed type -->  public String glide(Integer i, Integer j) {}
      Varargs --> public String glide(int... nums) {}

      Below example is interesting and tricky to understand -->
        public class TooManyConversions {
        public static void play(Long l) { }
        public static void play(Long... l) { }
        public static void main(String[] args) {
        play(4); // DOES NOT COMPILE
        play(4L); // calls the Long version
        } }
      
      --> The reason for comile error in above code is, because java won't be able to convert int primitive value to Long object type directly. For this it requires two step, first convert int primitive type to lonbg primitive type and then to Long object type. Hence, two step conversion directly is not possible in java right now and we received compile error.
      
------- Creating Constructors ----> a constructor is a special method that matches the name of the class and has no return type.
  Remember Java is case-sensitive.
      Constructors are used when creating a new object. This process is called instantiation because it creates a new instance of the class. A constructor is called when we write new followed by the name of the class we want to instantiate. For example: new Bunny()
     The this keyword tells Java you want to reference an instance variable. If you don’t say otherwise, Java gives you the one with the most granular scope.
     example:
      1: public class Bunny {
      2: private String color;
      3: public Bunny(String color) {
      4: this.color = color;  // notice, color = this.color is not allowed. code won't complie in that case.
      5: } }

  -------- Default Constructor --> Every class in Java has a constructor whether you code one or not. If you don’t include any constructors in the class, Java will create one for you without any parameters. This Java-created constructor is called the default constructor or no-arguments constructor.
    The default constructor has an empty parameter list and an empty body.
    We keep saying generated. This happens during the compile step.
    Remember that a default constructor is only supplied if there are no constructors present.
   ** Having a private constructor in a class tells the compiler not to provide a default noargument constructor. It also prevents other classes from instantiating the class. This is useful when a class only has static methods or the class wants to control all calls to create new instances of itself.
   
------- Overloading Constructors --> means, multiple constructors in the same class with same name as of class, as long as they have different method signatures.

  ---> Constructors can be called only by writing new before the name of the constructor. They are not like normal methods that you can just call.

    --> another tricky concept ---> When you have 2 constructors, means methods with same name as of class, but with different parameter and you want to call one constructor inside another, you can use this keyword, as discussed below. (page 200)
      When this is used as if it were a method, Java calls another constructor on the same instance of the class.
          public Hamster(int weight) {
          this(weight, "brown");
          }

      --> this() has one special rule! If you choose to call it, the this() call must be the first noncommented statement in the constructor. Comments don't run Java statements and are allowed anywhere.
      
      ------ Constructor Chaining --> Overloaded constructors often call each other. One common technique is to have each constructor add one parameter until getting to the constructor that does all the work. This approach is called constructor chaining.
      
 ------- Final Fields ---> final instance variables must be assigned a value exactly once. We saw this happen in the line of the declaration and in an instance initializer. There is one more location this assignment can be done: in the constructor.
 
  -------- Order of Initialization ---->  *** Very imp (page 202)    
        1. If there is a superclass, initialize it first (we’ll cover this rule in the next chapter. For now, just say “no superclass” and go on to the next rule.)
        2. Static variable declarations and static initializers in the order they appear in the file.
        3. Instance variable declarations and instance initializers in the order they appear in the file.
        4. The constructor.

      ///// Keep in mind that the four rules apply only if an object is instantiated. If the class is referred to without a new call, only rules 1 and 2 apply. The other two rules relate to instances and constructors. They have to wait until there is code to instantiate the object.

  ------- Encapsulating Data --> Encapsulation means we set up the class so only methods in the class with the variables can refer to the instance variables. Callers are required to use these methods. Example, getters (accessor method) and setters (mutator method) method.
      --> remember that data (an instance variable) is private and getters/setters are public.
      --> Encapsulating data is helpful because it prevents callers from making uncontrolled changes to your class.
  
Rules for JavaBeans naming conventions -->                     
1. Properties are private.  ---> Example:-- private int numEggs;
2. Getter methods begin with "is" if the property is a boolean. Example:--
    public boolean isHappy() {
    return happy;
    }
3. Getter methods begin with get if the property is not a boolean. Example:-- 
    public int getNumEggs() {
    return numEggs;
    }
4. Setter methods begin with set. return type is void.  Example:--
    public void setHappy(boolean happy) {
    this.happy = happy;
    }
5. The method name must have a prefix of set/get/is, followed by the first letter of the property in uppercase, followed by the rest of the property name. Example:--
    public void setNumEggs(int num) {
    numEggs = num;
    }


    ----- Creating Immutable Classes --> creating unchangable classes
      One step in making a class immutable is to omit the setters.
      but we include a constructor that allows a value to be set. This is to set initial value.
      Remember, immutable is only measured after the object is constructed. Immutable classes are allowed to have values. They just can't change after instantiation.
      
      
      **** important to remember --->
      encapsulation refers to preventing callers from changing the instance variables directly.
      Immutability refers to preventing callers from changing the instance variables at all.
        
--- Writing Simple Lambdas --->
  Functional programming is a way of writing code more declaratively. You specify what you want to do rather than dealing with the state of objects. You focus more on expressions than loops.
    --> a lambda expression is like a method that you can pass as if it were a variable.
    --> an interface specifies the methods that our class needs to implement.
    example, simplest lambda expressions -->
      a -> a.canHop();




