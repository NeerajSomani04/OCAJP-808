Chapter 2 -- Operators and Statements

--- Understanding Java Operators --
it is a special symbol that can be applied to a set of variables, values, or literals—referred to as operands—and that returns a result.
3 types --> unary, binary, and ternary
Java operators are not necessarily evaluated from left-to-right order.

Unless overridden with parentheses, Java operators follow order of operation from higher-to-lower precedence.
If two operators have the same level of precedence, then Java guarantees left-to-right evaluation.

Order of operator     precedence
Operator   ----------->      Symbols and examples
Post-unary operators   ----------->       expression++, expression--
Pre-unary operators   ----------->       ++expression, --expression
Other unary operators   ----------->       +, -, !
Multiplication/Division/Modulus   ----------->       *, /, %
Addition/Subtraction   ----------->      +, -
Shift operators   ----------->      <<, >>, >>>  (// not in OCA exam)
Relational operators   ----------->      <, >, <=, >=, instanceof
Equal to/not equal to   ----------->      ==, !=
Logical operators   ----------->      &, ^, |
Short-circuit logical operators   ----------->      &&, ||
Ternary operators   ----------->      boolean expression ? expression1 : expression2
Assignment operators   ----------->      =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=


---- Working with Binary Arithmetic Operators --> used to perform mathematical operations on variables, create logical expressions, as well as perform basic variable assignments.

  --- Arithmetic Operators -->  include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%)
, include the unary operators, ++ and --.
the multiplicative operators (*, /, %) have a higher order of precedence than the additive operators (+, -).
you can change the order of operation explicitly by wrapping parentheses around the sections you want evaluated first.

arithmetic operators may be applied to any Java primitives, except boolean and String
only the addition operators + and += may be applied to String values, which results in String concatenation.
The modulus (%), or remainder operator, is simply prints the remainder when two numbers are divided.

For integer values, division results in the floor value of the nearest integer that fulfi lls the operation, whereas modulus is the remainder value. 
For a given divisory, which is 3 in these examples, the modulus operation results in a value between 0 and (y - 1) for positive dividends. This means that the result of a modulus operation is always 0, 1, or 2.
Example: 
System.out.print(10 / 3); // Outputs 3
System.out.print(10 % 3); // Outputs 1

-- Numeric Promotion -->  Numeric Promotion Rules
    1. If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.
    2. If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value’s data type.
    3. Smaller data types, namely byte, short, and char, are first promoted to int any time they’re used with a Java binary arithmetic operator, even if neither of the operands is int. For the third rule, note that unary operators are excluded from this rule. For example, applying ++ to a short value results in a short value.
    4. After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.

Need to remember below tricky question:-
Q:-  What is the data type of x + y?
      double x = 39.21;
      float y = 2.1;
Answer:- Code will give compile error
Reason:- floating-point literals are assumed to be double, unless postfixed with an f, as in 2.1f.
    If y = 2.1f, then it will be promoted to double while calculating the expression.
    (similarly, we need do for long as well. example:- long x = 1078798685465L; but if we assign a valid int value to long then we don't need to postfix with L, for example:- long x = 7; would compile with no error.)
Q:- What is the data type of x / y?
      short x = 10;
      short y = 3;
Answer:- the output data type would be "int". as per 3rd rule.

---- Working with Unary Operators ---> a unary operator is one that requires exactly one operand, or variable, to function.
    they often perform simple tasks, such as increasing a numeric variable by one, or negating a boolean value.
    Unary operator ------> Description
        + ------>  Indicates a number is positive, although numbers are assumed to be positive in Java unless accompanied by a negative unary operator.
        - -----> Indicates a literal number is negative or negates an expression
        ++ -----> Increments a value by 1
        -- ------> Decrements a value by 1
        ! ------> Inverts a Boolean’s logical value

----- Logical Complement and Negation Operators ----> The logical complement operator, !, fl ips the value of a boolean expression.

-- there will be question on this in exam -->
Imp rule to remember ---> you cannot apply a negation operator, -, to a boolean expression, nor can you apply a logical complement operator, !, to a numeric expression. You will get compile error in such case.
--> in Java 1 and true are not related in any way, just as 0 and false are not related.

--- Increment and Decrement Operators --> ++ and --, respectively, can be applied to numeric operands and have the higher order or precedence, as compared to binary operators. In other words, they often get applied fi rst to an expression.
  --> pre-increment and pre--decrement operator, operator is placed before the operand, the operator is applied fi rst and the value return is the new value of the expression.
  ---> post-increment operator and the post-decrement operator, operator is placed after the operand, then the original value of the expression is returned, with operator applied after the value is returned.
      The following code snippet illustrates this distinction:
      int counter = 0;
      System.out.println(counter); // Outputs 0
      System.out.println(++counter); // Outputs 1
      System.out.println(counter); // Outputs 1
      System.out.println(counter--); // Outputs 1
      System.out.println(counter); // Outputs 0

--- Using Additional Binary Operators --> 
  -- Assignment Operators --> that modifi es, or assigns, the variable on the left-hand side of the operator, with the result of the value on the right-hand side of the equation. The simplest assignment operator is the = assignment, which you have seen already:
  int x = 1;
Java will automatically promote from smaller to larger data types, but it will throw a compiler exception if it detects you are trying to convert from larger to smaller data types.

Casting Primitive Values --> Casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a fl oating-point number to an integral value.
  example:- int x = (int)1.0;
            short y = (short)1921222; // Stored as 20678
            Using Additional Binary Operators 61
            int z = (int)9l;
            long t = 192301398193810323L;
            
---- Overflow and Underflow -->  The expressions in the previous example now compile, although there’s a cost. The second value, 1,921,222, is too large to be stored as a short, so numeric overfl ow occurs and it becomes 20,678. Overfl ow is when a number is so large that it will no longer fi t within the data type, so the system “wraps around” to the next lowest value and counts up from there. There’s also an analogous underfl ow, when the number is too low to fit in the data type. This is beyond the scope of the exam, but something to be careful of in your own code.
  For example, the following statement outputs a negative number:
  System.out.print(2147483647+1); // -2147483648
  Since 2147483647 is the maximum int value, adding any strictly positive value to it will cause it to wrap to the next negative number.        
Be wary of examples like this in exam:-
examples for a moment:
short x = 10;
short y = 3;
short z = x * y; // DOES NOT COMPILE
Based on everything you have learned up until now, can you understand why the last line of this statement will not compile? If you remember, short values are automatically promoted to int when applying any arithmetic operator, with the resulting value being of type int. Trying to set a short variable to an int results in a compiler error, as Java thinks you are trying to implicitly convert from a larger data type to a smaller one.

--- Compound Assignment Operators --->  Only two of the compound operators are required for the exam, += and -=.
  compound operators cannot be used to declare a new variable. Variables, should be declared before using this.
  compound oprator will automatically cast the lower data type value to upper data type value, while calculating the expression.
  inserting the assignment operator = in the middle of an expression and apply that value in calculation is completely valid. for example:- long y = (x=3);
          System.out.println(x); // Outputs 3
          System.out.println(y); // Also, outputs 3

---- Relational Operators ---> compare two expressions and return a boolean value
  < ---> Strictly less than
  <= ---> Less than or equal to
  > ----> Strictly greater than
  >= ---> Greater than or equal to

  a instanceof b ---> True if the reference that a points to is an instance of a class, subclass, or class that implements a particular interface, as named in b. (out of scope for OCA)
  
----- Logical Operators --->  (&), (|), and (^), may be applied to both numeric and boolean data types. 
  When they’re applied to boolean data types, they’re referred to as logical operators. 
  (out of scope for OCA) Alternatively, when they’re applied to numeric data types, they’re referred to as bitwise operators.

x & y (AND) --> if both are ture then only true, else always false.
x | y (INCLUSIVE OR) --> if any of this is true then true, else false.
x ^ y (EXCLUSIVE OR) --> if both are same then false, else true.

--- conditional operators --> && and ||, which are often referred to as short-circuit operators.
    nearly identical to the logical operators, & and |, respectively, except that the right-hand side of the expression may never be evaluated if the final result can be determined by the left-hand side of the expression. For example, consider the following statement:
    boolean x = true || (y < 4); // result is true, but we don't need to evaluate the right hand side expression (y<4) for that 
 /// useful in checking for null objects before performing an operation

----- Equality Operators ---> the equals operator == and not equals operator !=. they compare two operands and return a boolean value.
    The equality operators are strictly used in one of three scenarios: 
      1. Comparing two numeric primitive types. If the numeric values are of different data types, the values are automatically promoted as previously described. For example, 5 == 5.00 returns true since the left side is promoted to a double.
      2. Comparing two boolean values.
      3. Comparing two objects, including null and String values.

---- very important -----
For object comparison, the equality operator is applied to the references to the objects,
not the objects they point to. Two references are equal if and only if they point to the same
object, or both point to null. Let’s take a look at some examples:
File x = new File("myFile.txt");
File y = new File("myFile.txt");
File z = x;
System.out.println(x == y); // Outputs false
System.out.println(x == z); // Outputs true

---- Understanding Java Statements ---> 
A Java statement is a complete unit of execution in Java, terminated with a semicolon (;).




switch statement 
Data types supported by switch statements include the following:
■ int and Integer wrapper class
■ byte and Byte wrapper class
■ short and Short wrapper class
■ char and Character wrapper class
■ String
■ enum values

Note that boolean and long, and their associated wrapper classes, are not supported by switch statements.

default block --> if there is no matching case value for the switch statement, regardless of its position.

the data type for case statements must all match the data type of the switch variable.
the case statement value must be a literal, enum constant, or final constant variable.

Review questions:- Attempt 1
1. A, D
2. A, B, D, E, F (N)
3. F 
4. B, C, F (N)
5. C
6. F
7. F (N)
8. D (N)
9. B (N)
10. C (N)
11. A
12. D
13. A
14. C
15. E
16. E (N)
17. D 
18. B (N)
19. D 
20. C (N)
