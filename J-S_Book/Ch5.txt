Chapter 5 -- Class Design
Proper Java class design is about code reusability, increased functionality, and standardization.

------- Introducing Class Inheritance -->
Inheritance is the process by which the new child subclass automatically includes any public or protected primitives, objects, or methods defined in the parent class.
Java supports single inheritance, by which a class may inherit from only one direct parent class. Java does allow one exception to the single inheritance rule: classes may implement multiple interfaces, as you’ll see later in this chapter.
Each child has exactly one parent, but one parent can have multiple children.

Java doesn’t support multiple inheritance. Although, Java also supports multiple levels of inheritance. means one class (X) inherit other class (Y) and that class (Y) can inherit another class (Z).

It is possible in Java to prevent a class from being extended by marking the class with the final modifier. If you try a class that inherits from a final class, the compiler will throw an error and not compile.

--- Extending a Class --> using the extends keyword, adding the parent class name in the definition of child class. Example below:
    public abstract class ElephantSeal extends Seal {
        // Methods and Variables defined here
    }

    --> Java allows only one or zero public class or interface per file.
    --> any private members of parent class is not accessible directly to child class, but using object reference we can fetch private members.
    
--- Applying Class Access Modifiers -->
  The public access modifier applied to a class indicates that it can be referenced and used in any class. 
  The default package private modifier, indicates the class can be accessed only by a subclass or class within the same package.
  ---> The rules for applying class access modifi ers are identical for interfaces.

----- Creating Java Objects ---> In Java, all classes inherit from a single class, java.lang.Object. 
  java.lang.Object is the only class that doesn’t have any parent classes. This is top most class in java.
  
----- Defining Constructors -->
    every class has at least one constructor, if no constructor is declared, the compiler will automatically insert a default no argument constructor. 
    In Java, the first statement of every constructor is either a call to another constructor within the class, using this(), or a call to a constructor in the direct parent class, using super(). If a parent constructor takes arguments, the super constructor would also take arguments.
    Like the this() command, he super() command may only be used as the first statement of the constructor. code will not compile if this condition doesn't meet.


---- Understanding Compiler Enhancements --->
  Java compiler automatically inserts a call to the no-argument constructor super() if the first statement is not a call to the parent constructor.
 Subclasses may defi ne no-argument constructors even if their parent classes do not, provided the constructor of the child maps to a parent constructor via an explicit call of the super() command.

----- Reviewing Constructor Rules -->
    Constructor Definition Rules:
        1. The first statement of every constructor is a call to another constructor within the class using this(), or a call to a constructor in the direct parent class using super().
        2. The super() call may not be used after the first statement of the constructor.
        3. If no super() call is declared in a constructor, Java will insert a no-argument super() as the first statement of the constructor.
        4. If the parent doesn’t have a no-argument constructor and the child doesn’t define any constructors, the compiler will throw an error and try to insert a default no-argument constructor into the child class.
        5. If the parent doesn’t have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor.
    
------ Calling Constructors --> In Java, the parent constructor is always executed before the child constructor.
---- Calling Inherited Class Members --> 
    If the parent class and child class are part of the same package, 
        the child class may also use any default members defined in the parent class.
        A child class may never access a private member of the parent class, at least not through any direct reference.
    
    To reference a member in a parent class, you can just call it directly, or this and super may both be used for referencing methods or variables defined in the parent class, but only this may be used for referencing members defined in the current class.
    
    Remember, if the child class overrides a member of the parent class, this and super could have very different effects when applied to a class member.
    
------ super() vs. super ----> super() method vs super keyword ---> ** imp topic for exam
    super() and super are quite different but may be used in the same methods.
    The first, super(), is a statement that explicitly calls a parent constructor and may only be used in the first line of a constructor of a child class. 
    The second, super, is a keyword used to reference a member defined in a parent class and may be used throughout the child class.
        
---- Inheriting Methods --> brings the stage for collisions between methods defined in both the parent class and the subclass.   
    Lets discuss rules for method inheritance and how Java handles such scenarios.
    --- Overriding a Method -->
        means, a same method name and definition in both the parent and child class.
            When you override a method, you may reference the parent version of the method using the super keyword. In this manner, the keywords this and super allow you to select between the current and parent version of a method, respectively.
    
     -->   Rules, The compiler performs the following checks when you override a nonprivate method: -->
    1. The method in the child class must have the same signature as the method in the parent class.
    2. The method in the child class must be at least as accessible or more accessible than the method in the parent class.
    3. The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method. In other words, a child method may hide or eliminate a parent method’s exception without issue.
    4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types.

    
    ---> A recursive function is one that calls itself as part of execution, also it must have a termination condition to avoid infinite loop. in case of infinite loop, java throws/ produce a stack overflow error at runtime.
    
    --- overloading vs overriding ---->  
        If two methods have the same name but different signatures, the methods are overloaded, not overridden.
        overload --> Different signature for same name method
        override --> same signature for same name method, with few addional rules listed above.
     --- tips for exam -->
        Any time you see a method on the exam with the same name as a method in the parent class, determine whether the method is being overloaded or overridden first; doing so will help you with questions about whether the code will compile.
    
  ----- Redeclaring private Methods -->  
    in above discussion, we saw how public and protected methods can be overridden.
    In Java, it is not possible to override a private method in a parent class since the parent method is not accessible from the child class. but it doesn’t mean that the child class can’t define its own version of the method. It just means, that the new method is not an overridden version of the parent class’s method. so, none of the rules for overriding methods are invoked.
    
  ---- Hiding Static Methods -->
    A hidden method occurs when a child class defi nes a static method with the same name and signature as a static method defined in a parent class.
    hidden method follow all 4 rules of overridden method, plus addition one rule:
    5. The method defined in the child class must be marked as static if it is marked as static in the parent class (method hiding). Likewise, the method must not be marked as static in the child class if it is not marked as static in the parent class (method overriding).
    
    Note:- You should not reuse the name of a static method in your class if it is already used in the parent class. To avoid compile errors.

 ------ Overriding vs. Hiding Methods --->
    overriding a method --> a child method replaces the parent method in calls defined in both the parent and child.
          At runtime the child version of an overridden method is always executed for an instance regardless of whether the method call is defined in a parent or child class method.
          In this manner, the parent method is never used unless an explicit call to the parent method is referenced, using the syntax ParentClassName.method().
    hidden methods --> only replace parent methods in the calls defined in the child class.
        Alternatively, at runtime the parent version of a hidden method is always executed if the call to the method is defined in the parent class.
    
 ----- Creating final methods ---> (page 256 -- need to test concept with code run)
    one more rule: final methods cannot be overridden.
    This rule is in place both when you override a method and when you hide a method.
    In other words, you cannot hide a static method in a parent class if it is marked as final.
    one more point to Note that whether or not the child method used the final keyword is irrelevant—the code will not compile either way.
    
---- Why Mark a Method as final? ---> prevents them from being overridden
   In short, the final modifi er is only used on methods when the author of the parent method wants to guarantee very precise behavior.
   
----- Inheriting Variables ---> Java doesn’t allow variables to be overridden but instead hidden.
    --- Hiding Variables --> When you hide a variable, you defi ne a variable with the same name as a variable in a parent
class. This creates two copies of the variable within an instance of the child class: one instance defi ned for the parent reference and another defined for the child reference.
    there is no notion of overriding a member variable. 
    super keyword is used to access the parent variable’s value.
    These rules are the same regardless of whether the variable is an instance variable or a static variable.
    Notice if the same type of object was created then, the reference to the object determines which value is seen as output.

----- Creating Abstract Classes ---> 
    Abstract Class --> is a class that is marked with the abstract keyword and cannot be instantiated.
    An abstract method --> is a method marked with the abstract keyword defi ned in an abstract class, for which no implementation is provided in the class in which it is declared.

    Abstract Class Definition Rules:
        1. Abstract classes cannot be instantiated directly.
        2. Abstract classes may be defined with any number, including zero, of abstract and nonabstract methods.
        3. Abstract classes may not be marked as private or final.
        4. An abstract class that extends another abstract class inherits all of its abstract methods as its own abstract methods.
        5. The first concrete class that extends an abstract class must provide an implementation for all of the inherited abstract methods.
    Abstract Method Definition Rules:
        1. Abstract methods may only be defined in abstract classes.
        2. Abstract methods may not be declared private or final.
        3. Abstract methods must not provide a method body/implementation in the abstract class for which is it declared.
        4. Implementing an abstract method in a subclass follows the same rules for overriding a method. For example, the name and signature must be the same, and the visibility of the method in the subclass must be at least as accessible as the method in the parent class.
        
        
  ----- Creating a Concrete Class -->
    A concrete class is the first non-abstract subclass that extends an abstract class and is required to implement all inherited abstract methods.
    
---- extending an abstract class with another abstract --->
    An abstract class can extend another abstract class, and may or may not implement abstract methods of the extended class.
    But if an intermediate class provides an implementation for an abstract method, that method is inherited by subclasses as a concrete method, not as an abstract one.


------- Implementing Interfaces --> Java does allow classes to implement any number of interfaces. each separated by a comma.
    An interface is an abstract data type that defines a list of abstract public methods that any class implementing the interface must provide. An interface can also include a list of constant variables and default methods.
    An interface is defined with the interface keyword. 
    A class invokes the interface by using the implements keyword in its class definition.
    
** below topic very imp one or more question on this will be in exam
------ Defining an Interface --> specialized kind of abstract class. Below are rules:
    1. Interfaces cannot be instantiated directly.
    2. An interface is not required to have any methods.
    3. An interface may not be marked as final.
    4. All top-level interfaces are assumed to have public or default access, and they must include the abstract modifier in their definition. Therefore, marking an interface as private, protected, or final will trigger a compiler error, since this is incompatible with these assumptions.
    5. All nondefault methods in an interface are assumed to have the modifiers abstract and public in their definition. Therefore, marking a method as private, protected, or final will trigger compiler errors as these are incompatible with the abstract and public keywords.
    
----- Inheriting an Interface --> two inheritance rules:   
    1. An interface that extends another interface, as well as an abstract class that implements an interface, inherits all of the abstract methods as its own abstract methods.
2. The first concrete class that implements an interface, or extends an abstract class that implements an interface, must provide an implementation for all of the inherited abstract methods.
    
    abstract class vs interface --->
        1. Like an abstract class, an interface may be extended using the extend keyword. In this manner, the new child interface inherits all the abstract methods of the parent interface.
        2. Unlike an abstract class, though, an interface may extend multiple interfaces.
        
------- Classes, Interfaces, and Keywords ---> points to remember ---- (-- class implements interface --)
    A class can implement an interface, a class cannot extend an interface.
    Whereas, an interface can extend another interface, an interface cannot implement another interface.
    Also, An interface cannot extend a class.

------- Abstract Methods and Multiple Inheritance -->
   points to remember --> Scenario: what will happen if a class that inherits from two interfaces that contain the same abstract method:
        1. If only the abstract method name is same in both the interfaces, then one definition would be enough for both, in the concrete class and code will compile.
        2. If the method name is the same but the input parameters are different, there is no confl ict because this is considered a method overload.
        3. if the method name and input parameters are the same but the return types are different between the two methods, the class or interface attempting to inherit both interfaces will not compile. Even, if we implement one method definition then also compiler will complain as it is missing other method definition.
        3.2 - The compiler would also throw an exception if you defi ne an interface or abstract class that inherits from two conflicting interfaces. Even without implementation details, the compiler detects the problem with the abstract definition and prevents compilation.
   ---- things work a bit differently with default interface methods. Discussed below: ---
   

----- Interface Variables ---->  two interface variables rules:
    1. Interface variables are assumed to be public, static, and final. Therefore, marking a variable as private or protected will trigger a compiler error, as will marking any variable as abstract.
    2. The value of an interface variable must be set when it is declared since it is marked as final.
  Hence, point to understand -->
   1. interface variables are essentially constant variables defi ned on the interface level.
   2. they are assumed to be static, they are accessible even without an instance of the interface.
   3. it is a common coding practice to use uppercase letters to denote constant variable names within a class.
   
------ Default Interface Methods ---> (introduced in Java 8)
   Is a method with the default keyword in which a method body is provided, means default implementation. Contrast to abstract methods, which do not have method body. classes have the option to override the default method if they need to, but they are not required to do so.
   Note that methods are assumed to be public, as all methods of an interface are public.
       Below is an example of definition:-
            public interface IsWarmBlooded {
            boolean hasScales();
            public default double getTemperature() { // Note "public" as modifier and "default" as keyword for defining default method
            return 10.0;
            }
            }
    
    Default method rules -->
        1. A default method may only be declared within an interface and not within a class or abstract class.
        2. A default method must be marked with the default keyword. If a method is marked as default, it must provide a method body.
        3. A default method is not assumed to be static, final, or abstract, as it may be used or overridden by a class that implements the interface.
        4. Like all methods in an interface, a default method is assumed to be public and will not compile if marked as private or protected.

------ Default Methods and Multiple Inheritance ---->
     1. If a class implements two interfaces that have default methods with the same name and signature, the compiler will throw an error. There is an exception to this rule, though: if the subclass overrides the duplicate default methods, the code will compile without issue—the ambiguity about which version of the method to call has been removed.
    2. This rule holds true even for abstract classes that implement multiple interfaces, because the default method could be called in a concrete method within the abstract class. 
     
------ Static Interface Methods ----> (introduced in Java 8)
rules:
    1. Like all methods in an interface, a static method is assumed to be public and will not compile if marked as private or protected.
    2. To reference the static method, a reference to the name of the interface must be used.
    3. A static method defi ned in an interface is not inherited in any classes that implement the interface.
    4. a class that implements two interfaces containing static methods with the same signature will still compile at runtime, because the static methods are not inherited by the subclass and must be accessed with a reference to the interface name.
    
------ Understanding Polymorphism ----> the property of an object to take on many different forms.
    a Java object may be accessed using a reference:
        1. with the same type as the object
        2. a reference that is a superclass of the object
        3. a reference that defines an interface the object implements, either directly or through a superclass.
   Hence, a cast is not required if the object is being reassigned to a super type or interface of the object.
  The ability of an instance of a class to be passed as an instance of an interface it implements, as well as an instance of one of its superclasses, is the nature of polymorphism.
  Note:-- Once the object has been assigned a new reference type, only the methods and variables available to that reference type are callable on the object without an explicit cast.
  
---- Object vs. Reference -->  
     In Java, all objects are accessed by reference, you never have direct access to the object itself.
     Object --> The entity that exists in memory, allocated by the Java runtime environment.
            --> Regardless of the type of the reference for the object in memory, the object itself doesn’t change.
            
     the following two rules:
        1. The type of the object determines which properties exist within the object in memory.
        2. The type of the reference to the object determines which methods and variables are accessible to the Java program.       
            
