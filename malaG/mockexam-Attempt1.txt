1. B, C (N)
--> A reference variable of Derived (Child) class can't be used to refer an object of base (parent) class.
example:- 
class Animal {}
class Lion extends Animal implements Jumpable {}
--> you can explicitely cast any object to an interface, even if it doesn't implement it to make the compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
example:-
interface Jumpable {}
Jumpable var6 = (Jumpable)(new Animal()); // runtime exception
2. C
3. D
4. B
5. C, D
6. A
7. D
8. A, C, D
9. A, C
10. H
11. C (N)
--> remember below defaulty value for all primitive type --> 
--> char - \u0000 | byte,short,int - 0 | long - 0L | 
--> float - 0.0f | double - 0.0d | boolean - false | objects - null
--> but when these value passed to print method it will print without specific data type charachter (exmple, for float it will print 0.0, for long it will print 0, etc.)
--> Remember, you can't pass an uninitialized variable directly to print statement. (long ln; System.out.println(ln); // does not compile) --> we need to either initialze it or use it with class object (because java will initialze it then)  
12. A (N)
A reference variable of base class can't access variable and methods of child class without explicit cast. The best way to do that is:
--> ((LaserPrinter) myPrinter).pagePerMin; // casting to subclass
13. B (N)
--> The local variable (variables that are declared within a method) aren't initialzed with their default values. If you try to print the value of a local variable before initializing it, the code won't compile. 
--> On the other side, class and instance variable, initialize variable with default value.
14. C
15. D
16. D
17. B (N)
---> Always remember, if a main method needs to access a variable directly it must be static. or the variable can be access via instance variable.
--> because, a non-static variable can't be accessed via static method.
18. B (N)
--> Creation of an object of the class Emp requires the creation of an instance variable mgr and its initialization with an object of the same class. Hence, Emp object creation calls itself recusrsively, resulting in StackOverFlowError.
--> this is very tricky question. understand it through book explanation only. if above statement doesn't make sense.
19. A, E, G
20. A, B, D (N)
--> An array declaration becomes invalid, when you specify the size of  array within square bracket and declaring, instantiating and initializing an array at the single line of code.
example:-
int eArry5[] = new int[2] {10,20}; // this is invalid
int[] eArry2 = new int[10]; // valid
int eArry3[] = new int[] {}; // empty declaration is also valid
21. B, D
22. A, D (N) -- Re
--> need to check this again as this requires calculation
23. B, C
24. A, C, E -- Re
--> A constructor can't be defined using a non-access modifiers like, final, abstract or static
--> A constructor can't be defined with return type
--> A constructor can be defined with any access modifier, like public, private, protected, and package private(default)
25. A
26. E
27. A
28. A
29. D (N) -- Re
--> very tricky and nice question, need to understand it multiple time
--> concept, if you modify the state of the loop variable, the modified object state will be reflected in the array. but if you assign a new object to the loop variable, it won't be reflected in the list or the array that's being iterated. you can compare this behavior of the enhanced for loop variable with the behavior of object references passed as arguments to a method.
30. B (N) -- Re
--> static method of a class are hidden methods
--> calling static method is tied to the type of the reference variable and doesn't depend on the type of the object that's assigned to the reference variable. The static method belongs to a class and not to its objects. 
31. A, C, D
32. B, C
33. B (N)
--> static method can access only static members of a class. code won't compile otherwise.
34. B
35. D
36. A (N)
--> Substring method of String class can't accept negative value. (for example: str.substring(2, -1) will throw runtime exception).
37. B, E (N)
--> When an object reference is marked as null, the object is marked for garbage collection. But you can't be sure exactly when a garbage collector will kick in to garbage collect the objects. A garbage collector is low-priority thread, its execution depends on OS> you can never be sure about which object have been garbage collected. you can only be sure about how many objects are eligible for garbage collection.
38. A (N)
--> remember, equals method is a public method defined in java.lang.Object class, which is inherited by all classes. but default implementation of equals method is to compare the object reference pointing to same object, then return TRUE else FALSE. Any class can override this method to implement other logic. Here, no override happneded.
--> Need to check in general which classes overrides equals() method. 
39. A, C (N)
--> There is no concat method in StringBuilder. There is append method in StringBuilder to append any string.
--> Also, insert method can be used to insert char, number, or String at any specified position of StringBuilder.
40. A, C, D
41. E
42. E
43. B, D
44. G
45. D
46. B -- Re
--> explanation of this is same as question 38.
47. B
48. C
49. B (N) -- Re
--> break; statement breaks the execution of current loop. means, if you have a loop that should execute from 0 to 9 and you hit break; statement at 5 position then loop will not run for any value after 5, means from 6 to 9.
--> continue; statment, if you hit continue statment at 5 position, it will stop the current execution but continue run of loop from 6 to 9 value iteration.
--> also, remember, this break or continue statements are for iteration of loops (for, do, while) and not for if-else statement. 
50. D
51. C
52. B -- Re
--> any non-static method when inherited and overridden, reference variable refers to the objects created for that class. means, reference variable will refer to method based on object and not based on reference variable.  
53. A (N)
--> example with explanation:-
--> polymorphism (overloading and overridding), object vs reference variable 
Phone phone1 = new Phone(); // only phone members accessible, even child overridden method not accessible
		// Tablet tablet1 =  new Phone(); // compile error -- explicit cast is needed (Tablet)
	    // Tablet tablet1 = (Tablet) new Phone(); // compile successfully but ClassCastException at runtime
		Phone phone2 = new Tablet(); // only phone members accessible, child overridden method accessible
							// to access child members, need to cast explicitly //System.out.println(((Tablet)phone2).playmovie);
		Tablet tablet2 = new Tablet(); // all parent and child members accessible as child inherit them
54. D (N)
--> Code that tries to access an uninitialized local variable won't compile. 
55. A (N)
--> every object operations should be assigned to reference variable. if you don't assign object to reference variable, it is not stored and become elegible for garbage collection.
56. C (N)
--> each type of loop can accept single statement without curly braces but multiple statement should be inside curly braces.
57. A, C, D, F (N)
--> array should either declare size or initialze  properly.
below are few valid example:-
--> String egj2[] [] = new String [] [] { {}, {} };
--> String egj4 [] [] = new String [] [] {{null}, new String[] {"a", "b", "c"}, {new String()}};

58. C (N) --Re
--> you need to keep track of object initialization and its reference variables. 
--> In this case Laptop reference variable and life reference variable are referring to two different objects. ANy changes on these object will not impact each other.
59. D (N)
--> Any class object can be explicitly cast to any interface, code will compile but if that class doesn't implement that interface then ClassCastException will be thrown at runtime.
60. D
61. B
62. A
63. C (N)
--> "instanceof" is all smallcase letter operator to compare an object for its class instance.
64. B, C
65. A, D (N)
--> Remember, a constructor can't have return type. 
--> An overload method name and constructor name can be same but return type is the difference.
--> A base class can use reference variables and objects of its derived class. even as a method aurgument which is defined in base class.
66. E
67. A, B (N)
--> Any class that extends Exception class becomes a checked exception class.
--> Hence, when you call a method that throws a checked exception, you can either handle it using try-catch block or declare it to be thrown in caller method signature.
68. D
69. D
70. F
71. A, B, E
72. D
73. C
74. B
75. E
76. B (N)
--> Always remember to indent your code if it is unindented to avoid confusion.
77. C













































