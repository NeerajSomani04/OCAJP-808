--------- Content page -------------------------
Java Basics - 
Java Basics - OO Concepts -
Working with Java Data Types - 
Working with Java Data Types - Garbage Collection - 
Using Operators and Decision Constructs - 
Creating and Using Arrays - 
Using Loop Constructs - 
Constructors -
Working with Methods - 
Working with Methods - Overloading - 
Working with Inheritance - 
Working with Inheritance - instanceof -
Handling Exceptions - 
Lambda Expressions - 
Working with Java API - ArrayList - 
Working with Java API - String, StringBuilder - 
Working with Java API - Time and Date -

-----------Disclaimer notes-----------
1. In exam there could be few questions that does not follow standard naming convention. Be aware of that. like, class name in all smallcase letters. for those questions its ok, and we need to focus on concept.

***************************************Java Basics - ***************************************
--> Only java.lang package is imported automatically. All other packages must be imported explicitly.

--> It is not necessary for a java file to have a public class, but if public class (or enum) present, then file name must match the class name and that there can be only one public class (or enum) in a file.
	its possible to have a class name with small case letters but not java standard guidlines. 
	final is a valid modifier for the standard main method. 
	Note that final means a method cannot be overridden. Although static methods can never be overridden (they can be hidden), making a static method final prevents the subclass from implementing the same static method.

--> A ".java" file without main method can compile successfully. Although, It will not make the class executable from the command line.

There are three distinct meanings for the final keyword in Java.
A final class cannot be extended or can't be inherited.
A final method cannot be overridden.
A final variable cannot be assigned to another value after it has been initialized.

Example:- 
--> String, StringBuilder, and StringBuffer - all are final classes.
--> wrapper classes are also final class. (java.lang.Boolean, java.lang.Integer, java.lang.Long, java.lang.Short etc.)
-->  java.lang.System is final as well.
--> ** Although, java.lang.Number is not final. Integer, Long, Double etc. extend Number.

IS-A Relationship (inheritance)
* IS-A relationship also known as ‘inheritance’.
* By using extends keyword we can implement inheritance.
* The main advantage is reusability.

HAS – A Relationship
* Also known as Composition or Aggregation .
* There is no specific keyword, but most of the cases we can implemented by using new keyword.
* Main advantage is reusability.

example:- below example doesn't clear has-a relation 
When class A extends or implements B directly or indirectly, you can say that A is-a B. Here, Car directly extends Vehicle and directly implements Drivable. Therefore, a Car is-a Vehicle and a Car is-a Drivable.
Similarly, an SUV is-a Car and since Car is-a Vehicle and is-a Drivable, SUV is also a Vehicle and a Drivable.

Now, the rule is that if you have a container that is meant to contain A, then you can add anything that is-a A to that container. For example, if you have ArrayList<Car>, you can add a SUV to it because an SUV is-a Car. But if you have ArrayList<SUV>, you cannot add a Car to it because a Car is not an SUV.

--> If you have any line of code that is unreachable in the the entire life of program them compiler will complain and code does not compile.

--> Top level class can be public or default (means, no access modifier) and abstract or final non-access modifier are permitted.
--> private, protected and public can be applied to a nested class (not in OCA).
--> A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface.

--> synchronized can only be applied to a method or a block.
--> native method cannot be abstract.

-- Access modifiers ------ in most restrict to least restrict order ---
(most restrictive) private --> can be accessed only within same class.
default (package private) --> can be accessed only within same packages.
protected --> same package + subclasses (can be accessed only within same packages and other packages subclasses)
(least restictive) public --> can be accessed from anywhere.

--> you can't import default package, means classes or interfaces can be accessed only from within default package.

--> If you are using a variable in any specific statement that becomes undefined due to compile error than the statement which is using that variable will also throw compile error because that variable is undefined for that specific statement.

Three types of variables -->
Instance variable --> defined inside class. Auto initialized if not done explicitly. any modifier other than abstract."
class variable --> same as instance variable but with static keyword. (makes it hidden variable)
local variable --> defined within method, allow only "final" modifier and not auto initialized, hence must be initailized before use, else code won't compile.

--> example for implication of local variable --->
--> Now, observe that the calc method declares local variables coupon, offset, and base but does not assign them a value. Even though at run time, we know that since percent is 0 and is thus < 10, a value will be assigned to these variables, the compiler doesn't know this because the compiler doesn't take values of "variables" into consideration while determining the flow of control. It only considers the values of compile time constants. Therefore, as far as the compiler is concerned, coupon, offset, and base may remain uninitialized before they are used.
	Had percent been defined as final ( static final double percent = 0; ), the code would work. because compiler knows percent value at compile time and evaluate if statment to assign initial values to local variables.


-- Static keyword uses and key points --> 
in class declaration -->
in method declaration --> static method of a class are hidden methods (hence, it can't be overridden). can be called using a class name directly outside of class and can be called inside of class without even class name. or can be called using instance reference variable.
in variable declaration -->
in Interface declaration --> 

--> "import static ... ", syntext used to import static member of any class. If you imported using complete member path then no need to use even class name while using them.
example:- 
You can either import all the static members using import static java.lang.Integer.* or one specific member using import static java.lang.Integer.MAX_VALUE;
You must specify the full package name of the class that you are importing (just like the regular import statement). So, import static Integer.*; is wrong.
example:- import static java.lang.System.*; // valid (so that we can use out field of System, like this out.println("test"); directly.

--> a static member can access only static members but instance reference variable can access both static and non-static members.
example:- if a main method needs to access a variable directly it must be static. code won't compile otherwise.

--> calling static method is tied to the type of the reference variable and doesn't depend on the type of the object that's assigned to the reference variable. The static method belongs to a class and not to its objects. means, if reference variable is of parent class the static method of parent class would be called. Not the static method of child (because it can't be overridden). if reference variable of child class is used, then it will call child class static method.
      --> --> there is one exception, since child class inherit all method of parent, if child class doesn't define static method then on child class reference variable, parent class method would be called, as this static method of parent is now became a member of child class as well.

---> Although declaring a method static usually implies that it is also final, this is not true for classes. An inner class can be declared static and still be extended.

------- Key points Interface ---------
--> you can't instantiate an interface but you can create a reference of an interface to access its variable and methods.
--> for an interface declaration only public, default access modifier & abstract non-access modifier are permitted.
--> Fields in an interface are implicitly public, static and final. Although you can put these words in the interface definition but it is not a good practice to do so.
--> methods can be abstract (means no method body), default, or static. 
---> Interface doesn't inherits java.lang.Object class. because, interface can extends only other interfaces and not classes. Though an instance of an object (must be a class) that implements an interface inherits java.lang.Object. Otherwise, Java would support multiple inheritance for objects, which it doesn’t.
--> why we can see Objects class methods in interface because, An interface implicitly declared one method for each public method in Object. Thus the equals method is implicitly declared as a member in an interface (unless it already inherits it from a superinterface).

--> you are not allowed to use any java reserved keywords in your code as an identifier or in loop label. like, for, while, int, etc.
example:-
Note that for is a reserved keyword, hence we can't use "for" keyword in place of "String" which is used as loop label. But you can use any other identifier as a label.
For example, The following code is valid even though String is a class name and String is also used as an identifier!
     String String = "";   //This is valid.
     String : for(int i = 0; i< 10; i++) //This is valid too!
     {
        for (int j = 0; j< 10; j++){
             if ( i+ j > 10 )  break String;
        }
       System.out.println( "hello");
      }
It will print hello 2 times.

--> The Object class's toString generates a string using:  getClass().getName() + '@' + Integer.toHexString(hashCode())
--> But the String class overrides the toString() method that returns just the actual string value.

*************************************** Java Basics - OO Concepts -*************************************** 

--> Trying to override a static method with a non-static method (and vice-versa) in a class or interface will result in a compilation error. Although, You can, however, have a default method in a subinterface with the same signature as a static method of its super interface because a static method of an interface can only be called using that interface's name (as interface can't be instanctiated). 
Example:
interface I{
   public default void invalid(){ }
   public static void valid(){ } //Can be called only using I.valid();
}
interface I2 extends I{
   public static void invalid(){ } //WILL NOT COMPILE
   public default void valid(){ } //this is ok. 
}
-->  static and abstract can't be used together. 
-->  An abstract method doesn't require body but all other type of method required body. (static and default in case of interface) 
-->  An interface method cannot be default and static at the same time because a default method is always an instance method.

--> In this case Laptop reference variable and life reference variable are referring to two different objects. Any changes on any specific  object will not impact each other.

--- Key points about super and this keywords -----

----- super() & this() methods -->  
super() - to call parent class constructor.
this() - to call same class constructor.
--> can use super() or this() only in constructors first line not anywhere else, any attempt to do so will lead to compile-time error.
--> can NOT use both simultaneously.

---- super & this keyword --> 
super - to call parent class members(variables and methods). ("super" keyword represents the object of parent class)
this - to call same class members(variables and methods). (here "this" represents the reference to the same class object)
NOTE: We can use both of them anywhere in a class except static areas(static block or method), any attempt to do so will lead to compile-time error.

--> whenever you use "this" keyword, it basically returns the reference to the same class object. but this is happen because of the top Parent class "Objects". Every class implicitly extend this class. This Object calss implements toSting() method and default behaviour of toString method is to return current class object and convert that into string format. (example:- It will print TestClass@nnnnnnnn, where nnnnnnnn is the hash code of the TestClass object referred to by 'this'.) below is explanantion --> 

	--> The toString method for class Object returns a String consisting of the name of the class of which the object is an instance, the at-sign character '@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:
getClass().getName() + "@" + Integer.toHexString(hashCode())

--> if we override toString() method of Object class then the response of "this" keyword would depend on the return value of overridden toString() method.

-- Encapsulation --
--> An important aspect of encapsulation is that other classes should not be able to modify the state of fields of a class directly. Therefore, the data members variables should be private (or protected if you want to allow subclasses to inherit the field) and if the class wants to allow access to these fields, it should provide appropriate setters and getters with public access.

---- Multiple Inheritance --> 
--> Interfaces, classes, and enums are all "types". Java allows a class to implement multiple interfaces. In this way, Java supports multiple inheritance of types. 
"State", on the other hand, is represented by instance fields. Only a class can have instance fields and therefore, only a class can have a state. (Fields defined in an interface are always implicitly static, even if you don't specify the keyword static explicitly. Therefore, an interface does not have any state.) Since a class is allowed to extend only from one class at the most, it can inherit only one state. Thus, Java does not support multiple inheritance of state.

--> Methods do not have state. Ability to inherit instance methods from multiple classes is called multiple inheritance of implementation. 
Default methods introduce one form of multiple inheritance of implementation. A class can implement more than one interface, which can contain default methods that have the same name. However, such a class cannot be compiled. In this case, the implementing class is required to provide its own implementation of the common method to avoid ambiguity.

--> Multiple inheritance of state includes ability to inherit instance fields from multiple classes.
--> Multiple inheritance of type includes ability to implement multiple interfaces and/or ability to extend from multiple clases.

*************************************** Working with Java Data Types - ***************************************

--> below are default value for all primitive and object data type --> 
--> (unsigned) (16-bit)char - \u0000 (an empty space) | (8-bit)byte,short(16-bit),int(32-bit) - 0 | (64-bit)long - 0L | 
--> (32-bit)float - 0.0f | (64-bit)double - 0.0d | boolean - false | objects - null

--> other than boolean and char, all are signed data types.
--> Remember, when a char primitive data type used with arithmetic operators, its ASCII value is used, which is int value only. 
--> you can't assign a negative int value to a char data type without casting. (example, char ch = (char) -97;)

unsigned byte b = 0; // does not compile // There no unsigned keyword in java! A char can be used as an unsigned integer.

--> An implicit narrowing primitive conversion may be used if all of the following conditions are satisfied:
1. Allowed only if the type of the variable is byte, short, or char. (from int to any below is possible)
2. The expression is a compile time constant expression of type byte, char, short, or int.
3. The value of the expression is representable in the type of the assigned variable. (which is known at compile time, because it is a constant expression) 
--> Note that implicit narrowing conversion does not apply to long or double. So, char ch = 30L; will fail even though 30 is representable in char.

Remember these rules for primitive types:
1. Anything bigger than an int can NEVER be assigned to an int or anything smaller than int ( byte, char, or short) without explicit cast.
2. CONSTANT values up to int can be assigned (without cast) to variables of lesser size ( for example, short to byte) if the value is representable by the variable.( that is, if it fits into the size of the variable).
3. operands of mathematical operators are ALWAYS promoted to AT LEAST int. (i.e. for byte * byte both bytes will be first promoted to int.) and the return value will be AT LEAST int.
4. All Compound assignment operators ( +=, *= etc), internally do an explicit cast. have strange ways so read this carefully:
--> A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once. 
Note that the implied cast to type T may be either an identity conversion or a narrowing primitive conversion. 
For example, the following code is correct:
short x = 3;
x += 4.6;
and results in x having the value 7 because it is equivalent to: 
short x = 3;
x = (short)(x + 4.6);

---------------------------------------------
--> but when these value passed to print method it will print without specific data type charachter (exmple, for float (0.0f) it will print 0.0, for long (0L) it will print 0, etc.)

--> Conversion from char to long does not need a cast. 
--> Conversion from byte to short does not need a cast.
--> Conversion from short to char needs a cast. The reverse is also true. Because their ranges are not compatible.
--> a float can hold any value of int hence conversion or explicit casting not needed. Note that opposite is not true because of loss of precision.
--> Conversion from byte, char or short to int, long or float does not need a cast. Because int, long or float are bigger that byte, char or short.
--> float (32 bit) is smalled than double (64-bit), hence float can handle any integral primitive (byte, short, char, int, long) but can't accept double value. even negative integer is acceptable in float.
--> char (16-bit) and short (16-bit), hence explicit cast is needed. char can accept unsigned int value upto 16-bit.
--> float d = 0 * 1.5f; and float d = 0 * (float)1.5 ; are OK, (but not like float d = 0 * 1.5).
--> float f = -123; // ok - Implicit widening conversion will occur in this case.
example:- 
int i = 10;
byte b = 20;
b = i; //will not compile because byte is smaller than int
b = (byte) i; // will compile // type cast needed 
--> Further, if you have a final variable and its value fits into a smaller type, then you can assign it without a cast because compiler already knows its value and realizes that it can fit into the smaller type. This is called implicit narrowing.
final int k = 10;
b = k; //Okay because k is final and 10 fits into a byte
final float f = 10.0; //will not compile because 10.0 is a double even though the value 10.0 fits into a float
i = f; //will not compile, even if f is valid float value, because its not allowed // explicit cast needed

--- Different integer values --->
Binary --> 0 and 1
Decimal --> 0 to 9
OctaDecimal --> 0 to 7
Hexadecimal --> 0 to 9 and A (or a) to F (or f),  G and further is not allowed.

------------- how to put underscore (_) in between for any interger values ----
--> An underscore can only occur in between two digits. 
--> You may use underscore for all kinds of numbers including long, double, float, binary, as well as hex.  For example, the following are all valid numbers - 
int hex = 0xCAFE_BABE;
float f = 9898_7878.333_333f;
int bin = 0b1111_0000_1100_1100;

--> note if, x is primitive int. You cannot call any methods on a primitive. so this.x.setInt(...) or this.y.setInt(...) don't make any sense.

*************************************** Working with Java Data Types - Garbage Collection -  ***************************************

--> as soon as an object is set to null, the object held by the reference variable is free and is eligible for GC. 
--> when it gets Garbage collected will always be unknown.

A garbage collector is low-priority thread, its execution depends on OS> you can never be sure about which object have been garbage collected. you can only be sure about how many objects are eligible for garbage collection.

--> every object operations should be assigned to reference variable. if you don't assign object to reference variable, it is not stored and become eligible for garbage collection.

--> Garbage collection.  All you need to know is: --------------------------
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();

*************************************** Using Operators and Decision Constructs -  ***************************************

------ instanceof operator ---- type operator --- (all small-case letter)
--> used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false. 
 -- Few other example:- 
 
 System.out.println(s instanceof Short); // does not compile,  The left operand of instanceof MUST be a reference variable and not a primitive.
Short k = 9; System.out.println( k instanceof s); // does not compile, the Right operand of instanceof MUST be a reference type name, i.e., a class, an interface, or an enum name.

--> Division and modulus Operator (/ and %) --> will return int for data tyeps (int, short, byte, char), long (for long and below), float (if input is float), double (if input is double).

--> Logical opertators --> (&, |, ^) --> evaluates both operands.  (can have integral as well as boolean operands)
--> Short-circuit Logical operators --> (&& and ||) --> evaluates one operand for below cases and hence known as Short-circuit operator. (can have only on booleans operand)
&& --> if first expression is false then it won't evaluate second expression, (because overall result is false)
|| --> if first expression is true then it won't evaluate second expression. (because overall result is true)

--- Arithmetic Operators -->
--> The modulus operator % allow only integer operands. It can be used on floating points operands also. 
For example, 5.5 % 3 = 2.5

--> ~ Operates only on integral types

String values with (+) operator -->
question and example :-
   System.out.println(null + true); // compile error
   System.out.println(true + null); // compile error
   System.out.println(null + null); // compile error
   System.out.println(null + "good"); // compile successfully, and print "nullgood"
   
Concept Explanation -->
--> If one operand expression is of type String, then string conversion is performed on the other operand to produce a String at run time. The result is a reference to a newly created String object that is the concatenation of the two Strings. 
--> Any type may be converted to type String by string conversion.
--> A value x of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression e.g. if T is boolean, then use new Boolean(x) .
  toString() is defined by parent class Object; many classes override it, notably String and all Wrapper classes.

--> Below are the rules to understand any expression evaluation:
here, int i = 0; and The statement iA[i] = i = 30 ; will be processed as follows:
iA[i] = i = 30; => iA[0] = i = 30 ;  =>  i = 30; iA[0] = i ; =>   iA[0] = 30 ;

Here is what JLS says on this:
1 Evaluate Left-Hand Operand First  
2 Evaluate all Operands before Operation  
3 Evaluation Respects Parentheses and Precedence  
4 Argument Lists are Evaluated Left-to-Right  

--> a good question about how an expression can be evaluated with function and different operators
int s = 5;
s = s + s + mx(s) + ++s; 
s = 5 + 5 + mx(5) + 6; // value of s is assigned from left to right and evaluated individual oprands
s = 5 + 5+ 8 + 6; // evaluted function as its an oprand for expression
s = 24;

--> another example with little twist -->
Note that boolean operators have more precedence than =. (In fact, = has least precedence of all operators.)
so, in (b2 != b1 = !b2)  first b2 != b1 is evaluated (left operand of = operator) which returns a value 'false'. So the expression becomes "false = !b2". And this is illegal because false is a value and not a variable!

Had it been something like (b2 = b1 != b2) then it is valid because it will boil down to : b2 = false.

-----  Using Operators and Decision Constructs --
Object t = new Integer(107); // Integer wrapper class
int k = (Integer) t.intValue()/9; // invalid, casting of parent object reference to child reference 
Compiler will complain that the method intValue() is not available in Object. This is because the . operator has more precedence than the cast operator. Hence, "t" reference variable don't have any method as intValue().
So you have to write it like this:
    int k = ((Integer) t).intValue()/9; // valid way of casting, bracket will evaluate first
Now, since both the operands of / are ints, it is an integer division. This means the resulting value is only divisor and not the remainder. its truncated (and not rounded). Therefore, the above statement will print 11 and not 12.

--> Remember, when you use "/" this division operator, the result of its evaluation is only division and not remainder. (for example, 10/3 = 3 as a result and remainder 3 will be discarded). Hence this can be used in case statmenent to compare value against int variable of switch statment.
------
int i = 9; System.out.println(s == i); // Any two integral primitives can be compared using == operator.
(==) oprator can compare two objects reference variable as well.

*************************************** Using Loop Constructs - ***************************************

--> Need to memorize few java rules for loops --> 
1. while (false) { x=3; } is a compile-time error because the statement x=3; is not reachable;
2. Similarly, for( int i = 0; false; i++) x = 3; is also a compile time error because x= 3 is unreachable.
3. Although, In if(false){ x=3; }, although the body of the condition is unreachable, this is not an error because the JLS explicitly defines this as an exception to the rule. It allows this construct to support optimizations through the conditional compilation. For example 1:-
if(DEBUG){ System.out.println("beginning task 1"); } 
Here, the DEBUG variable can be set to false in the code while generating the production version of the class file, which will allow the compiler to optimize the code by removing the whole if statement entirely from the class file.
example 2:- 
if (false) { x=3; } // valid
for( int i = 0; i< 0; i++) x = 3; // valid // because for loop has some expression, that can be true. (not explicitly false)

--> each type of loop can accept single statement without curly braces but multiple statement should be inside curly braces.
--> remember, while loop validation condition runs at the very end as well, to make sure its not validating to true and any evaluation at this step can also make some change to final result. (for example, while(i++){} will increment i by 1 count).

---> --> concept, if you modify the state of the loop variable, the modified object state will be reflected in the array. but if you assign a new object to the loop variable, it won't be reflected in the list or the array that's being iterated. you can compare this behavior of the enhanced for loop variable with the behavior of object references passed as arguments to a method.

--> The point to note here is that the j in for loop is different from the instance member j. The for loop j is inside a method as well as inside the for loop. Therefore, j++ occuring in the for loop doesn't affect the while loop. The for loop prints 1 2 3 4 5.
The while loop runs for the values 0 to 5 i.e. 6 iterations. Thus, 1 2 3 4 5 is printed 6 times. Note that after the end of the while loop the value of j is 6.

--> nested if-else statements are very tricky. need to focus more on this. if there is any else statment (doesn't matter about its indentation in java), belongs to the most inner if statement. means, the inner if statement might conceivably own the else clause and outer most if doesn't have even any else clause. also, remember, there can't be 2 else associtaed with one if. its always if-else.

------------- switch statement basics ----
You should remember the following rules for a switch statement:

1. Only String, byte, char, short, int, and enum values can be used as types of a switch variable. (String is allowed since Java 7.) Wrapper classes Byte, Character, Short, and Integer are allowed as well.

2. Switch statment doesn't allow double, float, long and boolean primitive types.

3.  All case labels should be COMPILE TIME CONSTANTS. It is ok for Switch statement expression not to be COMPILE TIME CONSTANTS.

4. The case constants must be assignable to the switch variable. For example, if your switch variable is of class String, your case labels must use Strings as well. or if switch variable is of type int, case labels must use byte, short, char or int.

(same as 4) The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char's range is from 0 to 65535. Similarly, the following will not compile because 300 cannot be assigned to 'by', which can only hold values from -128 to 127.
byte by = 10;
switch(by){
    case 200 :  //some code;
    case 300 :  //some code;
}

5. No two of the case constant expressions may have the same value.
6. Default clause is not compulsory in switch consturt.
---------------------------

--> Case statment label requires a compile time constant variable/values. Even if you define a final variable, assigning a value to that variable in the next line, means after its declaration, java doesn't count it as compile time constant.

--> Java can performs integer calculations at compile time only, if there is no object for which value can be changed at run-time. 
Hence, if 2 case statement evaluate to same value then java throws a compile error.

------ break (optional label); and continue (optional label); ------- statments --- 

--> break; statement breaks the execution of current loop. means, if you have a loop that should execute from 0 to 9 and you hit break; statement at 5 position then loop will not run for any value after 5, means from 6 to 9.
--> break statement are valid in iteration of loops (for, do, while) and in switch statement but not in if-else statement.

--> continue; statment, if you hit continue statment at 5 position, it will stop the current execution but continue run of loop from 6 to 9 value iteration.
--> continue; statement are valid in iteration of loops only (for, do, while) but invalid in switch or if-else statement.

--> you can assign label to any statment in java file. but when that label is used with break statment, then that break statment must be within the scope of label. else code won't compile.
example:-
void crazyLoop(){
   int c = 0;
   JACK: while (c < 8){
       JILL: System.out.println(c); 
       if (c > 3) break JILL; else c++; // does not compile
   }
}
--> here, Because break JILL; would be valid only when it is within the block of code under the scope of the label JILL. 
In this case, the scope of JILL extends only up till System.out.println(c); and break JILL; is out of the scope of the label.

--> label can be applied to individual statment or block { } or loop. You can apply a label to any code block or a block level statement (such as a for statement) but not to declarations. For example: loopX : int i = 10;

--> Remember that a labeled break or continue statement must always exist inside that specific loop where the label is declared. in-case of nested loop need to make sure this part carefully. example below:-
Here, if(j == 4) break POINT1; is a labelled break that is occurring in the second loop while the label POINT1 is declared for the first loop.

--> Even if the break statment takes the control out of the try-catch-finally block, the finally clause will be executed. A break without a label breaks the current loop (i.e. no iterations any more) and a break with a label tries to pass the control to the given label.
'Tries to' means that if the break is in a try block and the try block has a finally clause associated with it then it will be executed.

--> Key points --  for loop and enhanced for loop---
--> ehanced for loop Cannot use an existing/predefined variable in the variable declaration part, means, you cannot declare same variable which you declared at class level. final is the only modifier (excluding annotations) that is allowed in the variable declaration part of for loop.
	 example:- class A { 
	 int i =0; int[][] intArr = {{0, 2, 5}}; 
	 for (i : intArr[0]){} // invalid, enhanced for loop (means, enhanced for loop can't use same class variable)
	 for (int j: intArr[0]){} // valid, enhanced for loop
	 for (; i<5; i++){} // valid, (means, regular for loop can use same class variable)
	 for (int k; k<0; k++){} //invalid, k must be declared and initialzed as well, to use it inside for loop

--> An enhanced for loop can iterate over an array or a Collection but not a Map.
--> An enhanced for loop needs either an array or an object of a class that implements java.lang.Iterable. Map does not implement Iterable, though you can use keySet() or values() methods to get a Collection (which extends Iterable) and then iterate over that Collection.
--> Since there is no explicit condition check written in the enhanced for loop code, it provides less opportunity to write code that causes infinite loop.
--> You cannot find out the number of the current iteration while iterating.


*************************************** Constructors - ***************************************

-------- Order of Initialization (instantiaing class) ---->  *** Very imp (page 202)    
1. If there is a superclass, initialize it first. (using super() or this()) 
2. Static variable declarations and static initializers in the order they appear in the file.
3. Instance variable declarations and instance initializers in the order they appear in the file.
4. Any other statements that is making any changes to instance variable in the order they appear in the file.
5. The constructor.
------------------------------------------------------

--> Remember, if a method aurgument expecting a double or float, you can't pass int value in the method aurgument.
on the other side, if method aurgument is of type long, then you can pass int value to it. (its like data type compatibility)

--> constructors or methods can have different access modifiers. (mean overloaded)

--> A constructor don't have any return type. 
--> A method must have return type just before method name. A method name and signature could be same as constructor, only distinction would be return type of method.
--> A constructor can't be defined using a non-access modifiers like, final, abstract or static.
--> A constructor can be defined with any access modifier, like public, private, protected, and package private(default)
--> constructors can not be inherited. 
--> The default constructor is provided by the compiler only when a class does not define ANY constructor explicitly. 
--> The access type of a default constructor (created by Java) is same as the access type of the class. Thus, if a class is public, the default constructor will be public.
--> A constructor is non-static, and so it can access directly both the static and non-static members of the class.

*************************************** Working with Methods - ***************************************


--> a method in an interface is implicitly (assumed to be) public. Hence, any class then implements this interface and its method should also be public.

--> remember, return; statement is used to end the execution of method. but where we use it is also important.
--> An abstract method must have the abstract keyword and must not have a method body i.e. { }.

*************************************** Working with Methods - Overloading / overriding - ***************************************

-------- Rules for overriding method (i.e. the one in the subclass) MUST HAVE:
1. same method name and same signature (type and order of parameters) (The names of the parameter types do not matter. For example, void methodX(int i) is same as void methodX(int k))
2. same return type in case of primitives, but if parent method return type is Object class type then overriden method can have subclass of that Object class type, this is also known as covariant return types).
3. The method in the child class must be at least as accessible or more accessible than the method in the parent class. (The concept here is that an overriding method cannot make the overridden method more private.) 
4. The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method. In other words, a child method may hide or eliminate a parent method’s exception without issue. but It can declare any RuntimeException in throws clause of overridden method.
5. you can make it abstract!! You would have to make the class as abstract as well though.

--> --> remember, equals method is a public method defined in java.lang.Object class, which is inherited by all classes. but default implementation of equals method is to compare the object reference pointing to same object, then return TRUE else FALSE. Any class can override this method to implement other logic. 
--> Need to check in general which classes overrides equals() method. (Sting, Array and ArrayList overrides equals method, StringBuilder doesn't override).

--> To call myMethod(int m, Object p, double d), you must pass exactly three parameters. If you try to pass less (or more) number of parameters, the code will not compile. Note that method parameters are not assigned default values.

It is possible to declare a method that can take any number of aurguments (this is possible because of vararg). For example: 
public static void someMethod(Object... params){
        System.out.println(params.length); }
You can call this method by passing any number of parameters. In this case, calling someMethod() without any parameter will print 0. i.e. the length of params array will be 0. params will NOT be null.

*************************************** Working with Inheritance - ***************************************

Basics of Inheritance -->
--> Which variable (or static method) will be used depends on the class that the reference variable is declared of. (B b)
--> Which instance method will be used depends on the actual class of the object that is referenced by the variable. (new B())

--- Rules for Overloading --> 
--> same method name but different parameters (either the number or their order are different)
--> Also, there is no restrcition on return type of method, It can be any primitive or object class. Return type of overloaded method need not to be covariant.

---------- polymorphism (overloading and overridding), object vs reference variable ----------------------
--> A base (parent) class can use reference variables and objects of its derived (child) class as a method aurgument which is defined in base class.

--> A reference variable of Derived (Child) class can't be used to refer an object of base (parent) class.
example:- 
Dog dog = new Animal(); // does not compile, object of parent class and reference of child class not allowed.
Animal animal = new Lion(); // valid -  it will access all Animal class members
((Lion) animal).age; // valid, explicitly casting to child class to access child class members ( in this case age)
Lion lion = new Lion(); // valid, child class object and child class reference

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
example:-
interface Jumpable {}
class Animal {}
class Lion extends Animal implements Jumpable {}
Jumpable var6 = (Jumpable)(new Animal()); // runtime exception

-------------
--> polymorphism (overloading and overridding), object vs reference variable 
Phone phone1 = new Phone(); // only phone members accessible, even child overridden method not accessible
// Tablet tablet1 =  new Phone(); // compile error -- explicit cast is needed (Tablet)
// Tablet tablet1 = (Tablet) new Phone(); // compile successfully but ClassCastException at runtime
Phone phone2 = new Tablet(); // only phone members accessible, child overridden method accessible
	// to access child members, need to cast explicitly //System.out.println(((Tablet)phone2).playmovie);
Tablet tablet2 = new Tablet(); // all parent and child members accessible as child inherit them

----------- Inheritance / Polymorphism (override, overload, hidden) ------------------
1. Interface variables are public static final implicitly, means constant and hidden. they can be called only using interface reference and not by any class who is implementing this interface.
2. In case of methods, an interface can have static, default or regular method with (public access modifier, this is implicit).
	--> static is again hidden method and can't be access directly but it can be accessed only using Interface name. example: Movable.test1();. means, you can't access it even using instance of derived class who is implementing it.
	--> default method can be empty or can give default implementation of a method. it can be overrided as well. it can also be access by interface reference variable in the class where class implemented an interface.
	--> regular method behaves also similar to default method. its an abstract method by default and can be overridden and accessed using reference variable of interface or derived class.

*************************************** Working with Inheritance - instanceof - ***************************************
-->  "instanceof" is all smallcase letter operator to compare an object for its class instance.
The instanceof operator returns true if the object-reference on its left, points to an object of class-type on its right, otherwise,
The instanceof operator returns false, if there is a mismatch between object reference and class-type. (notice even if class type doesn't match, it return false).

*************************************** Handling Exceptions - ***************************************

--> Different types of Exceptions -->
------ Unchecked (Runtime) Exception ---
java.lang.SecurityException -->  extends RuntimeException:
java.lang.ClassCastException --> extends RuntimeException:
java.lang.NullPointerException --> extends RuntimeException:
java.lang.IndexOutOfBoundsException --> extends RuntimeException
IllegalArgumentException ---> extends RuntimeException: 
IllegalStateException ---> extends RuntimeException:
------ checked Exception ---
java.lang.CloneNotSupportedException --> extends Exception
FileNotFoundException --> extends Exception
IOException --> extends Exception

Below are brief description of each Exception class -->
java.lang.SecurityException
SecurityException extends RuntimeException: It is thrown by the security manager upon security violation. For example, when a java program runs in a sandbox (such as an applet) and it tries to use prohibited APIs such as File I/O, the security manager throws this exception.
Since this exception is explicitly thrown using the new keyword by a security manager class, it can be considered to be thrown by the application programmer.

java.lang.ClassCastException
ClassCastException extends RuntimeException: Usually thrown by the JVM. Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance. For example, the following code generates a ClassCastException: 
     Object x = new Integer(0);
     System.out.println((String)x);

java.lang.NullPointerException
NullPointerException extends RuntimeException: Usually thrown by the JVM. Thrown when an application attempts to use null in a case where an object is required. These include: 
  Calling the instance method of a null object. 
  Accessing or modifying the field of a null object. 
  Taking the length of null as if it were an array. 
  Accessing or modifying the slots of null as if it were an array. 
  Throwing null as if it were a Throwable value. 
Applications should throw instances of this class to indicate other illegal uses of the null object.

java.lang.IndexOutOfBoundsException
IndexOutOfBoundsException extends RuntimeException: 
Usually thrown by the JVM. Thrown to indicate that an index of some sort (such as to an array, to a string, or to a vector) is out of range.  Applications can subclass this class to indicate similar exceptions.
ArrayIndexOutOfBoundsException and StringIndexOutOfBoundsException both extend IndexOutOfBoundsException.

IllegalArgumentException extends RuntimeException: If a parameter passed to a method is not valid. Usually thrown by the application.

IllegalStateException extends RuntimeException: Signals that a method has been invoked at an illegal or inappropriate time. In other words, the Java environment or Java application is not in an appropriate state for the requested operation. Usually thrown by the application. 

java.lang.CloneNotSupportedException
public class CloneNotSupportedException extends Exception
Thrown to indicate that the clone method in class Object has been called to clone an object, but that the object's class does not implement the Cloneable interface.
Applications that override the clone method can also throw this exception to indicate that an object could not or should not be cloned.

----------
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
      
 --> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.

Benefits of Java Exception Handling --->
--> It allows creation of new exceptions that are custom to a particular application domain.
--> It improves code because error handling code is clearly separated from the main program logic. The error handling logic is put in the catch block, which makes the main flow of the program clean and easily understandable.
--> It improves the code because the code does not have to include error handling code if it is not capable of handling it. It can propagate the exception up the chain and so that the exception can be handled somewhere at a more appropriate place.

questions:- Checked exceptions are meant for?
Answer:- exceptional conditions external to an application that a well written application should anticipate and from which it can recover.
explanation:- Note that here recovery doesn't necessarily mean to keep functioning normally. It means that the program shouldn't just crash. If it absolutely cannot proceed, it should notify the user appropriately and then end gracefully.

-->  Errors are meant for exceptional conditions from which recovery is difficult or impossible.
 --> Generally, if the exception is caused by problems internal to the program, a RuntimeException is used.

There are multiple view points regarding checked and and unchecked exceptions. As per the official Java tutorial ( http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html ) :  If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.
Here, the client basically means the caller of a method.

Another way to look at exceptions is to see the cause of the exception in terms of whether it is internal or external to the program's code. For example, an incorrectly written code may try to access a reference pointing to null, or it may try to access an array beyond its length. These are internal sources of exception. Here, using runtime exceptions is appropriate because ideally these problems should be identified while testing and should not occur when the program is ready for deployment. 

On the other hand, a program interacting with files may not be able to do its job at all if a file is not available but it should anticipate this situation. This is an external source of an exception and has nothing to do with a program's code as such. It is therefore appropriate to use a checked exception here.

--> ArrayIndexOutOfBoundException and StringIndexOutOfBoundException is a derived (child) class of IndexOutOfBoundException. 
Always remember, sequence of catch block is important based on Exception. Catch block of derived class should always come first than catch block of base class. Else, code doesn't compile.

In this case, guru() method is called inside a try block, when an error or exception occur in try block, java looks for catch block. It couldn't find in guru() method hence control goes to method() which is upper method and java looks for catch block in that, but found finally block. Hence, run the code for finally block and then throws error with JVM.
Note:- you can still catch an exception which was thrown using throw statement inside a method.

--> Runtime exception can be thrown without declaring them and exception methods can pass variable as an aurgument.
but checked exception either needs to be declared or handled.
Remember, you can even create an object of exception class like (new StackOverFlowErrorException()) and can use it as normal object.
Throwable is parent class of Exception class.

--> If a try block throw an exception and catch block handles it properly, then other catch block will not run, but if present finally block will run. Any statement after catch or finally block will execute as regular statement.
--> A finally block can't be placed before catch block.
--> finally is always executed (even if you throw an exception in try or catch) but this is the exception to the rule.
When you call System.exit(...); The JVM exits so there is no way to execute the finally block. 

--> If there is not catch block for a thrown exception then any uncaught exception will cause the JVM to kill the thread. means, Any remaining code of the method will not be executed.
--> The catch argument type declares the type of exception that the handler can handle and must be the name of a class that extends Throwable or Throwable itself.
--> A try without resources must have either a catch or a finally. It may have both as well.
--> A catch can catch multiple exceptions:
try{
}
catch(Exception1|Exception2|Exception3 e){  } 

--> Any class that extends Exception class becomes a checked exception.
--> Hence, when you call a method that throws a checked exception, you can either handle it using try-catch block or declare it to be thrown in caller method signature.

--- Printing an Exception --> three ways to print an exception
    1. let Java print it out, 
    2. print just the message, or
    3. print where the stack trace comes from
  This example shows all three approaches:
      5: public static void main(String[] args) {
      6: try {
      7: hop();
      8: } catch (Exception e) {
      9: System.out.println(e); // Just the name of the exception class and the message is printed.
      10: System.out.println(e.getMessage()); // print just the message
      11: e.printStackTrace(); // print complete chain of the names of the methods called, along with the line numbers
      12: }
      13: }
      14: private static void hop() {
      15: throw new RuntimeException("cannot hop");
      16: }
    This code results in the following output:
	java.lang.RuntimeException: cannot hop  // Just the name of the exception class and the message is printed.
	cannot hop
	java.lang.RuntimeException: cannot hop //print complete chain of the names of the methods called, along with the line numbers
	at trycatch.Handling.hop(Handling.java:15)
	at trycatch.Handling.main(Handling.java:7)
	
--> few java Exception classes example:-
java.io.FileNotFoundException   / java.io.IOException
java.lang.OutOfMemoryError      /  java.lang.StackOverflowError
java.lang.SecurityException. 
This exception extends RuntimeException and is thrown by the security manager upon security violation. For example, when a java program runs in a sandbox (such as an applet) and it tries to use prohibited APIs such as File I/O, the security manager throws this exception.
Since this exception is explicitly thrown using the new keyword by a security manager class, it can be considered to be thrown by the application programmer.

Any checked exceptions must either be handled using a try block or the method that generates the exception must declare that it throws that exception. 
In this case, doA() declares that it throws Exception. doB() is calling doA but it is not handling the exception generated by doA(). So, it must declare that it throws Exception. Now, the main() method is calling doB(), which generates an exception (due to a call to doA()). Therefore, main() must also either wrap the call to doB() in a try block or declare it in its throws clause.

The main(String[] args) method is the last point in your program where any unhandled checked exception can bubble up to. After that the exception is thrown to the JVM and the JVM kills the thread.

*************************************** Lambda Expressions - ***************************************
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - 
interface Predicate<T> {
    boolean test(T t);
}

provided by the standard java library in java.util.function package.
The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.

--> Lambda expression points to be noted:-
Predicate is typed to List (not ArrayList) in the checkList method, therefore, the parameter type in the lambda expression must also be List. It cannot be ArrayList.
The add method of ArrayList returns a boolean. Further, it returns true if the list is altered because of the call to add. In this case, al.add("hello") indeed alters the list because a new element is added to the list.

---- lambda expression --
Predicate interface type listed in your method must match the type that you pass through lambda.
Predicate is typed to List (not ArrayList) in the checkList method, therefore, the parameter type in the lambda expression must also be List. It cannot be ArrayList.

If interface method does not take any parameter, the parameter list part of the lambda expression must be (). Further, if interface method is void means, it does not return anything, the body part should ideally be such that it does not return anything either.


*************************************** Creating and Using Arrays - ***************************************

Array Basic points -->
1. An array of objects can store Objects of any class.
2. Primitives (i.e. int, byte, char, short, boolean, long, double, and float) are NOT objects.
3. An array (of primitives as well as of objects) is an Object.

This is valid way for creating array:-
--> new Object[]{ "aaa", new Object(), new ArrayList(), 10}; // 10 is a primitive and not an Object but due to auto-boxing it will be converted into an Integer object and that object will then be stored into the array of Objects.

This is invalid way for creating array:-
--> new Object[]{ "aaa", new Object(), new ArrayList(), {} }; //{} is not a valid way to create an Object here. However, it is valid while creating an array. For example, the following are valid:
String[] sa = { }; //assigns a valid String[] object of length 0 to sa
Object arr[][] = new Object[][] {new String[5], {} }; //assigns a valid Object[] object of length 0 to arr[1].

--------------------
--> String[] sA = new String[1] { "aaa"}; // does not compile // Array can't declare and initialze at the same line.
Array size cannot be given here as the array is being initialized in the declaration.


--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> A null pointer is different from an array of length zero. A reference being null or pointing to null means it is not pointing to anything at all. But an array of length zero is a valid object. Thus, a reference pointing to such an array is not pointing to null.
For example, if you have int[] intArr = new int[0]; then (intArr == null) is false.

--> you can't assign an Array of char to an Array of int data type.
Array and ArrayList are very specific to its datatype, means you can't pass any other data type values to it.
not even char or byte can compare with int and int can't be comapred with long type array. all are independent to specific type.
--> An array element can be assigned to null.

--> you can't initialize an array with new keyword and array default construtor like in general we do for all other class. Instead, Array is initialzed using new keyword followed by type of array. {(example:- new Array() not allowed), (but int arr[] = new int[5] is allowed)}
Also remember, you can't create an array like this "int arr[] = new int[]", means you must either give array dimensions or array initializer values. even creating empty array is legal, means Array of Zero length. 
like int arr[] = new int[5], or int arr[] = new int[] {5, 2}, or int arr[] = new int[] {} // all valid
String[] sA = {new String( "aaa")}; // valid

--> An array declaration becomes invalid, when you specify the size of array within square bracket and declaring, instantiating and initializing an array at the single line of code.
example:-
int eArry5[] = new int[2] {10,20}; // this is invalid

--- very imp example --- 
int i = 4;
int ia[][][] = new int[i][i = 3][i];
System.out.println( ia.length + ", " + ia[0].length+", "+ ia[0][0].length); // 4, 3, 3

Explanation:- In an array creation expression, there may be one or more dimension expressions, each within brackets. Each dimension expression is fully evaluated before any part of any dimension expression to its right. The first dimension is calculated as 4 before the second dimension expression sets 'i' to 3.
Note that if evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated.
// also notice above the way we accessed "ia" array in three different ways. 
// ia --> 3D array, because its an array of 2D aray 
ia[0] --> will return 2D array, accessing 0th position 2D array of ia-3D array
ia[0][0] --> will return 1D array, because we are going to access the 1D array.

For Arrays: First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.

--> If the array reference expression produces null instead of a reference to an array, then a NullPointerException is thrown at runtime, but only after all parts of the array reference expression have been evaluated and only if these evaluations completed normally. 

This means, first index = 2 will be executed, which assigns 2 to index. After that null[2] is executed, which throws a NullPointerException. But this exception is caught by the catch block, which prints nothing. So it seems like NullPointerException is not thrown but it actually is.
In other words, the embedded assignment of 2 to index occurs before the check for array reference produced by getArray().
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. Note that if evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated.

means, first array should be build properly. Then only we will go to access it. then any other part of the statement will be evaluated.
Remember, whenever you will refer null and perform operation on it. it will throw NullPointerException.


*************************************** Working with Java API - ArrayList - ***************************************

-----------------------------
Classes that overrides equals method ----
--> String , Array and Arraylist override equals method, because they want to compare values passing to them.
--> SringBuffer/StringBuilder -- don't override equals method because these are mutable classes and hence, equals method on them perform default implementation that is object comparision, same as (==).

--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
    
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class
ArrayList clear() method is used to remove all elements of ArrayList.
ArrayList remove() method is used to remove specific element of ArrayList.
If you frequently add elements to ArrayList, its a good idea to create an ArrayList of large size.
Calling Clone() method on an ArrayList will create a separate reference variable that stored the same number of elements as the original ArrayList. But each individual ArrayList element will still refer to original object, means, ArrayList elements are not cloned.
An ArrayList can store any type of objects. Wrapper classes are created for ArrayList only.

--> The method contains() of ArrayList accepts an object and compares it with the actual values of the list. Means, it behaves very similar to equals() method, which checks objects actual value and not object itself.

lets understand ArrayList with some example:-

ArrayList<Double> al = new ArrayList<>(); // created one arraylist object
--> Note that al is declared as ArrayList<Double>, therefore the add method is typed to accept only a Double. (al.add(11.1);)
--> indexOf's accepts Object as a parameter. Although 1.0 is not an object, it will be boxed into a Double object. 
System.out.println(al.indexOf(1.0));
--> System.out.println(al.contains("string")); // this is valid, it will return false obviously
--> Double d = al.get(al.length); // does not compile
ArrayList does not have a field named length. It does have a method named size() though. So you can do:
Double d = al.get(al.size()); It will compile but will throw IndexOutOfBoundsException at run time in this case because al.size() will return 0 and al.get(0) will try to get the first element in the list.

private ArrayList<Integer> scores;
Change getScores to return a copy of the scores list:
   public ArrayList<Integer> getScores(){ 
     return new ArrayList(scores); 
  }
If you return the same scores list, the caller would be able to add or remove elements from it, thereby rendering the average incorrect.
This can be prevented by returning a copy of the list.

--> When you create an array of Objects ( here, Strings) all the elements are initialized to null. So in the line 3, null is assigned to myStr.
Note that. empty string is "" ( String str = ""; ) and is not same as null.

--> some Array vs Arraylist points
An ArrayList resized dynamically at run time as per the situation. An array cannot be resized once created. This reduces the amount of boiler plate code that is required to do the same task using an array.
Neither an ArrayList nor an array is thread safe. If you have multiple threads trying to add and remove elements from an ArrayList or an array, you have to write additional code to ensure thread safety.
arrays do not implement Collection interface. ArrayList does. This is actually an advantage of an ArrayList over an array.

--> The concept to understand here is as follows -
If the compiler can figure out that something can NEVER happen, then it flags an error. In this question, the compiler knows that ln, i or d can never point to the same object in any case because they are references to different classes of objects that have no relation ( superclass/subclass ) between themselves. Although, equals() method can be applied to any of them for comparision, as equals methods takes Objects as Aurgument.
example:-
Integer i = new Integer(42);
Long ln = new Long(42);
Double d = new Double(42.0);

--> ArrayList is a subclass of AbstractList.
--> Below is the class hirarchy for ArrayList. Means, ArrayList extends AbstractList, which extracts AbstractCollection<E> and ulimately it extends Object class.

java.lang.Object
 -  java.util.AbstractCollection<E>
   -    java.util.AbstractList<E>
     -      java.util.ArrayList<E>

--> Below are All Interfaces that ArrayList Implements -->
Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess

RandomAccess --> It allows you to access its elements in random order.
This is true because you can directly access any element using get(index) method. (This is unlike a LinkedList, in which you have to go through all the elements occuring before Nth element before you can access the Nth element.)

--> ArrayList can still use non-generic form. For example, instead of using
ArrayList<String> listOfStrings;
you can use:
ArrayList listOfStrings;
Of course, if you use non generic version, you will lose the compile time type checking.

--> RandomAccess is a marker interface used by List implementations to indicate that they support fast (generally constant time) random access. The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists. 

--> You can sort ArrayList elements using Collections.sort() method.
An ArrayList is a List so you can use it where ever a List is required. This include Collections methods such as sort, reverse, and shuffle.

*************************************** Working with Java API - String, StringBuilder - ***************************************

------------- facts about String Class ---- Q. 13 (Test 1)
These are the six facts on Strings:
1. Literal strings within the same class in the same package represent references to the same String object. 
2. Literal strings within different classes in the same package represent references to the same String object. 
3. Literal strings within different classes in different packages likewise represent references to the same String object. 
4. Strings computed by constant expressions are computed at compile time and then treated as if they were literals. 
5. Strings computed at run time are newly created and therefore are distinct. (So line 4 prints false.)
6. The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents. (So line 5 prints true.)

example:- below lines in testPackage.Test.java file.
 	String hello = "Hello", lo = "lo";
      System.out.print((testPackage.Other.hello == hello) + " ");    //line 1 // true
      System.out.print((other.Other.hello == hello) + " ");   //line 2 //true
      System.out.print((hello == ("Hel"+"lo")) + " ");           //line 3 // true
      System.out.print((hello == ("Hel"+lo)) + " ");              //line 4 // false
      System.out.println(hello == ("Hel"+lo).intern());          //line 5 // true

----------
String s = null;
s = s + 'C'; // this will assign "nullC" string value to s. keep in mind.

Since newStr is null at the beginning, the first iteration of the loop assigns "nullg" to newStr. Therefore, at the end of the loop, newStr is actually "nullgood".
Had newStr been defined as String newStr = ""; then the program would have printed false for newStr == myStr because both the references are pointing to two different objects, and true for newStr.equals(myStr) because both the objects contain the exact same String.

--> System.out.println(s + sb); // addision operator can be applied to String and StringBuilder both. // here s is String object and sb is StringBuilder object.


----- String / StringBuilder --
1. When one of the operands of the + operator is a String and other is an object (other than String), toString method is called on the other operand and then both the Strings are concatenated to produce the result of the operation.
2. Object class contains an implementation of toString that returns the name of the class (including the package name) and the hash code of the object in the format <classname>@<hashcode>. For example, System.out.println("Hello, "+new Object()); will print Hello, java.lang.Object@3cd1a2f1, where 3cd1a2f1 is the hash code of the object.
3. StringBuilder class provides its own implementation of toString method, which returns the String value of its contents.

In this question, StringWrapper class does not implement toString method and so Object class's version is used.


--> The getClass method always returns the Class object for the actual object on which the method is called irrespective of the type of the reference. Since s refers to an object of class String, s.getClass returns Class object for String  and similarly list.getClass returns Class object for ArrayList.
example:- 	List<String> list = new ArrayList<>();
		StringBuilder sb = new StringBuilder("mrx");
		String s = sb.toString();
		list.add(s);
		System.out.println(s.getClass()); // class java.lang.String
		System.out.println(list.getClass()); // class java.util.ArrayList
    
 --> following are valid methods of String class:- trim, length, concate, and hashCode,
--> following are valid method for StringBuilder/StringBuffer --> reverse() 
(Note, reverse method is not available in String class)   

--> to find out whether two strings are equal or not,  in terms of the actual characters within the strings. What is the best way to do this? Answer:- use String's equals method. (example: x1.equals(x2))

String String = "String"; is a perfectly valid syntax! 
Java does not allow variables to have the same name as keywords (if, for, else, while, class etc.) and literals (true, false, and, null) but there is no restriction on naming variables after the names of classes. In this case, therefore, String is a valid variable name.

In case there is a conflict between variable name and class name, if the variable is in scope then it is the variable that is accessed instead of the class. For example, consider the following code
String String  = "test";
System.out.println(String.length());//prints 4
Here, the variable String is in scope and therefore the length of the string pointed to by the variable String is printed. The compiler does not confuse it with the class name String.
--> IndexOutOfBoundsException - if the any index in substring function is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex.

--> Need to understand all StringBuilder and String methods.

------> some concepts about charAt() method --->
Since indexing starts with 0, the maximum value that you can pass to charAt is length-1.
As per the API documentation for charAt, it throws IndexOutOfBoundsException if you pass an invalid value.
Both - ArrayIndexOutOfBoundsException and StringIndexOutOfBoundsException, extend IndexOutOfBoundsException and although in practice, the charAt method throws StringIndexOutOfBoundsException, it is not a valid option because the implementation is free to throw some other exception as long as it is an IndexOutOfBoundsException. There are questions in the exam on this aspect.


--> --> Substring method of String class can't accept negative value. (for example: str.substring(2, -1) will throw runtime exception).
--> its important to remember which string method takes what type of arguments, for example, 
method "indexOf" can accept both String and char values.
method startsWith and endsWith can accept only String values. Can't accept char value.
method charAt can accept only method aurgument of type int. but remember, since java stored char values as unsigned integer values, its possible to pass char values as well in this method.
example:- 
String te = "12345";
System.out.println(te.charAt('3')); // in this case it will throw exception StringIndexOutOfBoundsException, because charachter '3' is equal to (51) in unsigned integer value.
System.out.println(te.charAt(3)); // this will compile successfully and print 4
--> StringBuilder default object capacity is 16 char. (StringBuilder sb1 = new StringBuilder();)
--> --> There is no concat method in StringBuilder. There is append method in StringBuilder to append any string.
--> Also, insert method can be used to insert char, number, or String at any specified position of StringBuilder.

There are 2 points to remember:
1. replace(char oldChar, char newChar) method returns the same String object if both the parameters are same, i.e. if there is no change. Thus, "String" == "String".replace('g', 'g') will return true.
2. replace(CharSequence oldSeq,  CharSequence newSeq) method returns a new String object even if there is no change after replacement. Thus, "String" == "String".replace("g", "g") will return false.

Wrapper class --

----------- Wrapper class concepts -->
1. new Long(mStr); // this is valid as, Auto unboxing will occur // here Long Wrapper class use constructor to convert the value
2. Long.parseLong(mStr); // this is valid and it will return primitive value for any string aurgument
3. Long.valueOf(mStr).longValue(); // Long.valueOf(mStr) returns a Long object containing 123. longValue() on the Long object returns 123, which long primitive type value.
4. Long.longValue(mStr); // invalid, does not compile // longValue() is a non-static method in Long class, hence longValue() method can be accessed by reference variable only.
5. (new Long()).parseLong(mStr); // invalid, does not compile, Long (or any wrapper class) does not have a no-args constructor.

Notes - 3 points:
--> The string passed to second constructor should be parse-able to number , otherwise you will get run time NumberFormatException.
--> Wrapper Class Character has only one constructor which takes char type as an argument. It doesn’t have a constructor which takes String as an argument. Because, String can not be converted into Character.
--> Wrapper class Float has three constructors. The third constructor takes double type as an argument.

	Byte B1 = new Byte((byte) 10);     //Constructor which takes byte value as an argument
        Byte B2 = new Byte("10");          //Constructor which takes String as an argument
        //Byte B3 = new Byte("abc");      //Run Time Error : NumberFormatException
        //Because, String abc can not be parse-able to byte
 
        Short S1 = new Short((short) 20);   //Constructor which takes short value as an argument
        Short S2 = new Short("10");         //Constructor which takes String as an argument
 
        Integer I1 = new Integer(30);     //Constructor which takes int value as an argument
        Integer I2 = new Integer("30");   //Constructor which takes String as an argument
 
        Long L1 = new Long(40);      //Constructor which takes long value as an argument
        Long L2 = new Long("40");    //Constructor which takes String as an argument
 
        Float F1 = new Float(12.2f);      //Constructor which takes float value as an argument
        Float F2 = new Float("15.6");   //Constructor which takes String as an argument
        Float F3 = new Float(15.6d);    //Constructor which takes double value as an argument
 
        Double D1 = new Double(17.8d);       //Constructor which takes double value as an argument
        Double D2 = new Double("17.8");     //Constructor which takes String as an argument
 
        Boolean BLN1 = new Boolean(false);       //Constructor which takes boolean value as an argument
        Boolean BLN2 = new Boolean("true");      //Constructor which takes String as an argument
	// If you pass a string other than true or false to the second constructor of Boolean wrapper class, the object is initialized with false. example: Boolean BLN3 = new Boolean("abc");     //passed string "abc" // return false boolean value
	
 
        Character C1 = new Character('D');      //Constructor which takes char value as an argument
        Character C2 = new Character("abc");    //Compile time error : String abc can not be converted to character
		
--> You need to remember the following points about Boolean:

1. Boolean class has two constructors - Boolean(String) and Boolean(boolean)
The String constructor allocates a Boolean object representing the value true if the string argument is not null and is equal, ignoring case, to the string "true". Otherwise, allocate a Boolean object representing the value false (even if you pass null). Examples: new Boolean("True") produces a Boolean object that represents true. new Boolean("yes") produces a Boolean object that represents false.

The boolean constructor is self explanatory.

2. Boolean class has two static helper methods for creating booleans - parseBoolean and valueOf.
Boolean.parseBoolean(String ) method returns a primitive boolean and not a Boolean object (Note - Same is with the case with other parseXXX methods such as Integer.parseInt - they return primitives and not objects). The boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string "true". 

Boolean.valueOf(String ) and its overloaded Boolean.valueOf(boolean ) version, on the other hand, work similarly but return a reference to either Boolean.TRUE or Boolean.FALSE wrapper objects. Observe that they dont create a new Boolean object but just return the static constants TRUE or FALSE defined in Boolean class.

3. When you use the equality operator ( == ) with booleans, if exactly one of the operands is a Boolean wrapper, it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). If both are Boolean wrappers, then their references are compared just like in the case of other objects. Thus, new Boolean("true") == new Boolean("true") is false, but new Boolean("true") == Boolean.parseBoolean("true") is true.

--> Signature of equals method is : boolean equals(Object o); So it can take any object.
The equals methods of all wrapper classes first check if the two object are of same class or not. If not, they immediately return false. 
The default implementation of equals method is to compare the reference, but few classes overrides that default behavior and compare actual value of those objects.

--> Compiler will complain that the method intValue() is not available in Object. This is because the . operator has more precedence than the cast operator. So you have to write it like this:
    int k = ((Integer) t).intValue()/9;
Now, since both the operands of / are ints, it is an integer division. This means the resulting value is truncated (and not rounded). Therefore, the above statement will print 11 and not 12.



*************************************** Working with Java API - Time and Date - ***************************************

--> most imp points for JAVA Date-Time API:------------------------------
Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - 

--> They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date.

-->  java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField.

-->  LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate --> contains just the date information and no time information, 
LocalTime --> contains only time and no date.
LocalDateTime --> contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. 

--> These classes are immutable and have no public constructors. You can create objects of these classes using their static factory methods such as of(...) and from(TemporalAccessor ).  For example, 
LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); // Month is a special class here that accept month name
LocalDate ld = LocalDate.from(anotherDate); 
LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM

--> Since these classes are immutable means you can't modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(...). For example, 
LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY));

--> Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc.  For example - 
        
LocalDate date = LocalDate.parse("2015-01-01", DateTimeFormatter.ISO_LOCAL_DATE); // notice here you can't pass datetime or time
System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE)); // only LocalDate object can be used here
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME)); // only LocalTime object can be used here
System.out.println(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)); // only LocalDateTime object can be used here

The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn't directly cast the returned values to concrete classes like this - 
   LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"); //will compile but may or may not throw a ClassCastException at runtime.
You should do like this - 
   LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"));

--> Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds.

Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

-----
--> format method of LocalDate / Time can be applied only on object of LocalDate / Time or DateTimeFormater object. not on any string or text value.

example:-- 
LocalDate d1 = LocalDate.parse("2015-02-05", DateTimeFormatter.ISO_DATE);
        LocalDate d2 = LocalDate.of(2015, 2, 5);
        LocalDate d3 = LocalDate.now();
        System.out.println(d1); // it will print:- 2015-02-05
        System.out.println(d2); // it will print:- 2015-02-05
        System.out.println(d3); // it will print:- 2015-02-05
