--> There are all primitive type wrapper class. no need to get confuse.
--> switch statement limitation --> it can't accept long, boolean, double and float value in its consturct aurgument.
--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class

------ instanceof operator ---- type operator ---
used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
  
--> an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method.

--> 
