--> There are all primitive type wrapper class. no need to get confuse.
--> switch statement limitation --> it can't accept long, boolean, double and float value in its consturct aurgument.
--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> System.out.println(s + sb); // addision operator can be applied to String and StringBuilder both. // here s is String object and sb is StringBuilder object.

--> The getClass method always returns the Class object for the actual object on which the method is called irrespective of the type of the reference. Since s refers to an object of class String, s.getClass returns Class object for String  and similarly list.getClass returns Class object for ArrayList.
example:- 	List<String> list = new ArrayList<>();
		StringBuilder sb = new StringBuilder("mrx");
		String s = sb.toString();
		list.add(s);
		System.out.println(s.getClass()); // class java.lang.String
		System.out.println(list.getClass()); // class java.util.ArrayList


--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class
--> A null pointer is different from an array of length zero. A reference being null or pointing to null means it is not pointing to anything at all. But an array of length zero is a valid object. Thus, a reference pointing to such an array is not pointing to null.
For example, if you have int[] intArr = new int[0]; then (intArr == null) is false.

------ instanceof operator ---- type operator ---
used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
  
--> an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. Above statement valid for class objects. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method.

--> Code that tries to access an uninitialized local variable won't compile.
--> each type of loop can accept single statement without curly braces but multiple statement should be inside curly braces.
--> In this case Laptop reference variable and life reference variable are referring to two different objects. Any changes on any specific  object will not impact each other.

--> A .java file must have only one public class or one public interface, and file name should be the same as public class or interface. A .java file can have multiple class or interfaces.
--> for an interface only public, default access modifier & abstract non-access modifier are permitted.
--> for a class only public, default access modifier, and abstract & final non-access modifier are permitted.

-----------------------------------------------------------------------
--> most imp points for JAVA Date-Time API:------------------------------
Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - 

1. They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date.

2. java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField.

3. LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate contains just the date information and no time information, LocalTime contains only time and no date, while LocalDateTime contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. 

These classes are immutable and have no public constructors. You can create objects of these classes using their static factory methods such as of(...) and from(TemporalAccessor ).  For example, 
LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); or LocalDate ld = LocalDate.from(anotherDate); or LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM

Since you can't modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(...). For example, 
LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY));

4. Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc.  For example - 
        
LocalDate d1 = LocalDate.parse("2015-01-01", DateTimeFormatter.ISO_LOCAL_DATE);

The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn't directly cast the returned values to concrete classes like this - 
   LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"); //will compile but may or may not throw a ClassCastException at runtime.
You should do like this - 
   LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"));

5. Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds.

Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

------------------------------------------------------

--> The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char, whose
values are 16-bit unsigned integers representing UTF-16 code units.
--> & can have integral as well as boolean operands. (unlike &&), & will not "short circuit" the expression if used on boolean parameters. means it will evaluate both operands or both side expression.
--> The logical operators, (&), (|), and (^), evaluates both operands, but is similar as (&& or ||, respectively)
It may be applied to both numeric (known as bit-wise opertaor - not in OCA) and boolean (known as logical operators) data types.

--> The modulus operator % can only be used with integer operands. It can be used on floating points operands also. For example, 5.5 % 3 = 2.5
--> !, && and || operate only on booleans.
--> ~ Operates only on integral types

short-circuit operators --> 
&& --> if first expression is false then it won't evaluate second expression.
|| --> if first expression is true then it won't evaluate second expression.

--> following are valid methods of String class:- trim, length, concate, and hashCode,
--> following are valid method for StringBuilder/StringBuffer --> reverse() 
(Note, reverse method is not available in String class)

----------------------------
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - 
interface Predicate<T> {
    boolean test(T t);
}

provided by the standard java library in java.util.function package.
The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.

-------------------------------------------
private, protected and public can be applied to a nested class (not in OCA).A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface.

synchronized keyword can never be applied to a class or non-primitive variables. It can only be applied to a method or a block.
final keyword can be applied to class, variable and methods.
final keyword when applied to a class means the class cannot be subclassed, when applied to a method means the method cannot be overridden (it can be overloaded though) and when applied to a variable means that the variable is a constant.
A final variable can be hidden in a subclass.

--> native method cannot be abstract.
----------------------------
non-public class can't be accessed outside a package in which it is defined, even if it is explicitely imported. Because class itself is not accessible / visible. Only protected class can be accessed if you have import and inherite (extend) them and use it with child class object. 

--> You can't import classes from the default package. The only way to access classes in the default package is from another class in the default package. A class or interface that is defined in any other package can't access classes or interfaces defined in default package.

--> Also, remember, Java allows a class to only public or package private (default). there is no concept of class with private modifier unless it is a nested class.

--> Remember, when a char primitive data type used with arithmetic operators, its ASCII value is used, which is int value only. 

--> you can't assign a negative int value to a char data type without casting. (example, char ch = (char) -97;)
If you are using a variable in any specific statement that becomes undefined due to compile error than the statement which is using that variable will also through compile error because that variable is undefined for it.

---------------------- constructors and general methods -------------
--> Remember, if a method aurgument expecting a double or float, you can't pass int value in the method aurgument.
on the other side, if method aurgument is of type long, then you can pass int value to it.
--> you can define overloaded constructors or methods with different access modifiers.
Remember, a constructor don't have any return type. But a class can have a method name and signature same as constructor, only distinction would be return type of method.
--> A constructor can't be defined using a non-access modifiers like, final, abstract or static
--> A constructor can't be defined with return type
--> A constructor can be defined with any access modifier, like public, private, protected, and package private(default)
--> constructors can not be inherited.
--> The default constructor is provided by the compiler only when a class does not define ANY constructor explicitly. 
--> The access type of a default constructor (created by Java) is same as the access type of the class. Thus, if a class is public, the default constructor will be public.
--> A constructor is non-static, and so it can access directly both the static and non-static members of the class.
---------------------------------- 

--> you can't assign an Array of char to an Array of int data type.
Array and ArrayList are very specific to its datatype, means you can't pass any other data type values to it.
not even char or byte can compare with int and int can't be comapred with long type array. all are independent to specific type.
--> An array element can be assigned to null.

--> you can't initialize an array with new keyword and array default construtor like in general we do for all other class. Instead, Array is initialzed using new keyword followed by type of array. {(example:- new Array() not allowed), (but int arr[] = new int[5] is allowed)}
Also remember, you can't create an array like this "int arr[] = new int[]", means you must either give array dimensions or array initializer values. even creating empty array is legal, means Array of Zero length. 
like int arr[] = new int[5], or int arr[] = new int[] {5, 2}, or int arr[] = new int[] {} // all valid
String[] sA = {new String( "aaa")}; // valid

--> An array declaration becomes invalid, when you specify the size of array within square bracket and declaring, instantiating and initializing an array at the single line of code.
example:-
int eArry5[] = new int[2] {10,20}; // this is invalid

--> Switch statment accepts variables of type String. and since an Arraylist can have String values, it can be passed to switch construct as well.
--> Switch statement can't accept boolean, long, double, and float primitive data type and its wrapper classes as an aurgument. 
--> Switch statement can accept only byte, short, char, int data type and its wrapper class. it can also accept String, and enum.

ArrayList clear() method is used to remove all elements of ArrayList.
ArrayList remove() method is used to remove specific element of ArrayList.
If you frequently add elements to ArrayList, its a good idea to create an ArrayList of large size.
Calling Clone() method on an ArrayList will create a separate reference variable that stored the same number of elements as the original ArrayList. But each individual ArrayList element will still refer to original object, means, ArrayList elements are not cloned.
An ArrayList can store any type of objects. Wrapper classes are created for ArrayList only.

--> The method contains() of ArrayList accepts an object and compares it with the actual values of the list. Means, it behaves very similar to equals() method, which checks objects actual value and not object itself.

-------------------------------------
--> format method of LocalDate / Time can be applied only on object of LocalDate / Time or DateTimeFormater object. not on any string or text value.
--> remember, while loop validation condition runs at the very end as well, to make sure its not validating to true and any evaluation at this step can also make some change to final result.
--> Case statment label requires a compile time constant variable/values. Even if you define a final variable, assigning a value to that variable in the next line, means after its declaration, java doesn't count it as compile time constant.
Remember, when you use "/" this division operator, the result of its evaluation is only division and not remainder. (for example, 10/3 = 3 as a result and remainder 3 will be discarded). Hence this can be used in case statmenent to compare value against int variable of switch statment.
--> Java performs integer calculations at compile time only, if there is no object for which value can be changed at run-time. 
Hence, if 2 case statement evaluate to same value then java throws a compile error.

--> you can't instantiate an interface but you can create a reference of an interface to access its variable and methods.
--> a method in an interface is implicitly (assumed to be) public. Hence, any class then implements this interface and its method should also be public.
--> The easiest way to identify the StackOverflowError is to find out the recursive call of method.

--> ArrayIndexOutOfBoundException and StringIndexOutOfBoundException is a derived (child) class of IndexOutOfBoundException. 
Always remember, sequence of catch block is important based on Exception. Catch block of derived class should always come first than catch block of base class. Else, code doesn't compile.

--> remember, return; statement is used to end the execution of method. but where we use it is also important.
In this case, guru() method is called inside a try block, when an error or exception occur in try block, java looks for catch block. It couldn't find in guru() method hence control goes to method() which is upper method and java looks for catch block in that, but found finally block. Hence, run the code for finally block and then throws error with JVM.
Note:- you can still catch an exception which was thrown using throw statement inside a method.

--> Runtime exception can be thrown without declaring them and exception methods can pass variable as an aurgument.
but checked exception either needs to be declared or handled.
Remember, you can even create an object of exception class like (new StackOverFlowErrorException()) and can use it as normal object.
Throwable is parent class of Exception class.

--> If a try block throw an exception and catch block handles it properly, then other catch block will not run, but if present finally block will run. Any statement after catch or finally block will execute as regular statement.
--> A finally block can't be placed before catch block.
--> finally is always executed (even if you throw an exception in try or catch) but this is the exception to the rule.
When you call System.exit(...); The JVM exits so there is no way to execute the finally block. 

--> If there is not catch block for a thrown exception then any uncaught exception will cause the JVM to kill the thread. means, Any remaining code of the method will not be executed.
--> The catch argument type declares the type of exception that the handler can handle and must be the name of a class that extends Throwable or Throwable itself.
--> A try without resources must have either a catch or a finally. It may have both as well.
--> A catch can catch multiple exceptions:
try{
}
catch(Exception1|Exception2|Exception3 e){  } 

--> Any class that extends Exception class becomes a checked exception.
--> Hence, when you call a method that throws a checked exception, you can either handle it using try-catch block or declare it to be thrown in caller method signature.

-->  "instanceof" is all smallcase letter operator to compare an object for its class instance.

---------- polymorphism (overloading and overridding), object vs reference variable ----------------------
--> A base (parent) class can use reference variables and objects of its derived (child) class. even as a method aurgument which is defined in base class.

--> A reference variable of Derived (Child) class can't be used to refer an object of base (parent) class.
example:- 
Dog dog = new Animal(); // does not compile, object of parent class and reference of child class not allowed.
Animal animal = new Lion(); // valid -  it will access all Animal class members
((Lion) animal).age; // valid, explicitly casting to child class to access child class members ( in this case age)
Lion lion = new Lion(); // valid, child class object and child class reference
example:- 
--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
example:-
interface Jumpable {}
class Animal {}
class Lion extends Animal implements Jumpable {}
Jumpable var6 = (Jumpable)(new Animal()); // runtime exception

---> a protected member is accessible in the subclass only using a reference whose declared type is of the same subclass (or its subclass.). 
-------------
--> polymorphism (overloading and overridding), object vs reference variable 
Phone phone1 = new Phone(); // only phone members accessible, even child overridden method not accessible
// Tablet tablet1 =  new Phone(); // compile error -- explicit cast is needed (Tablet)
// Tablet tablet1 = (Tablet) new Phone(); // compile successfully but ClassCastException at runtime
Phone phone2 = new Tablet(); // only phone members accessible, child overridden method accessible
	// to access child members, need to cast explicitly //System.out.println(((Tablet)phone2).playmovie);
Tablet tablet2 = new Tablet(); // all parent and child members accessible as child inherit them

-----------------------------------------------------

--> --> remember below defaulty value for all primitive type --> 
--> (16-bit)char - \u0000 | (8-bit)byte,short(16-bit),int(32-bit) - 0 | (64-bit)long - 0L | 
--> (32-bit)float - 0.0f | (64-bit)double - 0.0d | boolean - false | objects - null


An implicit narrowing primitive conversion may be used if all of the following conditions are satisfied:
1. The expression is a compile time constant expression of type byte, char, short, or int.
2. The type of the variable is byte, short, or char.
3. The value of the expression (which is known at compile time, because it is a constant expression) is representable in the type of the variable.
Note that implicit narrowing conversion does not apply to long or double. So, char ch = 30L; will fail even though 30 is representable in char.

--> but when these value passed to print method it will print without specific data type charachter (exmple, for float it will print 0.0, for long it will print 0, etc.)
--> The local variable (variables that are declared within a method) aren't initialzed with their default values. If you try to print the value of a local variable before initializing it, the code won't compile. 
--> On the other side, class and instance variable, initialize variable with default value.
--> Conversion from char to long does not need a cast. 
Conversion from byte to short does not need a cast.
Conversion from short to char needs a cast. The reverse is also true. Because their ranges are not compatible.
a float can hold any value of int hence conversion or explicit casting not needed. Note that opposite is not true because of loss of precision.
Conversion from byte, char or short to int, long or float does not need a cast. Because int, long or float are bigger that byte, char or short.
--> float (32 bit) is smalled than double (64-bit), hence float can handle any integral primitive (byte, short, char, int, long) but can't accept double value. even negative integer is acceptable in float.
--> char (16-bit) and short (16-bit), hence explicit cast is needed. char can accept unsigned int value upto 16-bit.
--> float d = 0 * 1.5f; and float d = 0 * (float)1.5 ; are OK, (but not like float d = 0 * 1.5).
--> float f = -123; // ok - Implicit widening conversion will occur in this case.


int i = 10;
byte b = 20;
b = i;//will not compile because byte is smaller than int
b = (byte) i; //OK
Further, if you have a final variable and its value fits into a smaller type, then you can assign it without a cast because compiler already knows its value and realizes that it can fit into the smaller type. This is called implicit narrowing and is allowed between byte, int, char, and, short but not for long, float, and double.
final int k = 10;
b = k; //Okay because k is final and 10 fits into a byte
final float f = 10.0;//will not compile because 10.0 is a double even though the value 10.0 fits into a float
i = f;//will not compile.

--------------------

--> a static member can access only static members but instance member can access both static and non-static (instance) members.
example:- if a main method needs to access a variable directly it must be static.   code won't compile otherwise.

--> static method of a class are hidden methods
--> calling static method is tied to the type of the reference variable and doesn't depend on the type of the object that's assigned to the reference variable. The static method belongs to a class and not to its objects. means, if reference variable is of parent class the static method of parent class would be called. Not the static method of child (because it can't be overridden). if reference variable of child class is used, then it will call child class static method.
      --> --> there is one exception, since child class inherit all method of parent, if child class doesn't define static method then on child class reference variable call, parent method would be called, as this static method of parent is now became a member of child class as well.

---> --> concept, if you modify the state of the loop variable, the modified object state will be reflected in the array. but if you assign a new object to the loop variable, it won't be reflected in the list or the array that's being iterated. you can compare this behavior of the enhanced for loop variable with the behavior of object references passed as arguments to a method.

--> --> Substring method of String class can't accept negative value. (for example: str.substring(2, -1) will throw runtime exception).
--> its important to remember which string method takes what type of arguments, for example, 
method "indexOf" can accept both String and char values.
method startsWith and endsWith can accept only String values. Can't accept char value.
method charAt can accept only method aurgument of type int. but remember, since java stored char values as unsigned integer values, its possible to pass char values as well in this method.
example:- 
String te = "12345";
System.out.println(te.charAt('3')); // in this case it will throw exception StringIndexOutOfBoundsException, because charachter '3' is equal to (51) in unsigned integer value.
System.out.println(te.charAt(3)); // this will compile successfully and print 4
--> StringBuilder default object capacity is 16 char. (StringBuilder sb1 = new StringBuilder();)
--------------------------------
--> --> When an object reference is marked as null, the object is marked for garbage collection. But you can't be sure exactly when a garbage collector will kick in to garbage collect the objects. A garbage collector is low-priority thread, its execution depends on OS> you can never be sure about which object have been garbage collected. you can only be sure about how many objects are eligible for garbage collection.

--> --> remember, equals method is a public method defined in java.lang.Object class, which is inherited by all classes. but default implementation of equals method is to compare the object reference pointing to same object, then return TRUE else FALSE. Any class can override this method to implement other logic. Here, no override happneded.
--> Need to check in general which classes overrides equals() method. 

--> --> There is no concat method in StringBuilder. There is append method in StringBuilder to append any string.
--> Also, insert method can be used to insert char, number, or String at any specified position of StringBuilder.

------------ break and continue statements -------------
--> break; statement breaks the execution of current loop. means, if you have a loop that should execute from 0 to 9 and you hit break; statement at 5 position then loop will not run for any value after 5, means from 6 to 9.
--> break statement are valid in iteration of loops (for, do, while) and in switch statement but not in if-else statement.
--> continue; statment, if you hit continue statment at 5 position, it will stop the current execution but continue run of loop from 6 to 9 value iteration.
--> continue; statement are valid in iteration of loops only (for, do, while) but invalid in switch or if-else statement.

-------------------------------------------------------------
--> every object operations should be assigned to reference variable. if you don't assign object to reference variable, it is not stored and become eligible for garbage collection.

--> The underscore can't be placed in between (0_x or 0_b) or even just after the initials (0b_10 or 0x_25). only exception it can be placed after first 0 (ex:- 0_1010_11). For hexaDecimal values the letter can be till f or F only, G and further is not allowed.

--> --> An abstract method must have the abstract keyword and must not have a method body i.e. { }.

--> variable types in a class ----
"class level" means static fields and they can be accessed from anywhere (i.e. static as well as non-static methods) in the class (and from outside the class depending on their accessibility).
"instance level" means the instance fields and they can be accessed only from instance methods in the class.
local variables are basically defined within a method and it must be initailized before use, else code won't compile.

--> correct order of restrictiveness for access modifiers...
public < protected < package (i.e. no modifier) < private
--> Members with default accessibility are only accessible within the class itself and from classes in the same package.
Protected members are in addition accessible from subclasses. Members with private accessibility are only accessible
within the class itself.

--> To call myMethod(int m, Object p, double d), you must pass exactly three parameters. If you try to pass less (or more) number of parameters, the code will not compile. Note that method parameters are not assigned default values.
It is possible to declare a method that can take variable number of parameters. For example: 
public static void someMethod(Object... params){
        System.out.println(params.length); }
You can call this method by passing any number of parameters. In this case, calling someMethod() without any parameter will print 0. i.e. the length of params array will be 0. params will NOT be null.

--> The visibility of the class is not limited by the visibility of its members. A class with all the members declared private can still be declared public or a class having all public members may be declared private.

--> Note that calling super(); will not always work because if the super class has defined a constructor with arguments and has not defined a no args constructor then no args constructor will not be provided by the compiler. It is provided only to the class that does not define ANY constructor explicitly.

--> Fields in an interface are implicitly public, static and final. Although you can put these words in the interface definition but it is not a good practice to do so.

--> You cannot apply any modifier except final to a local variable. i.e. you cannot make them transient, volatile, static, public, and private.
But you can apply access modifiers (public private and protected) and final, transient, volatile, static to instance variables.
You cannot apply native and synchronized to any kind of variable.

------------- switch statement basics ----
You should remember the following rules for a switch statement:

1. Only String, byte, char, short, int, and enum values can be used as types of a switch variable. (String is allowed since Java 7.) Wrapper classes Byte, Character, Short, and Integer are allowed as well.

2. The case constants must be assignable to the switch variable. For example, if your switch variable is of class String, your case labels must use Strings as well.

3. The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char's range is from 0 to 65535. Similarly, the following will not compile because 300 cannot be assigned to 'by', which can only hold values from -128 to 127.
byte by = 10;
switch(by){
    case 200 :  //some code;
    case 300 :  //some code;
}

4.  All case labels should be COMPILE TIME CONSTANTS. It is ok for Switch statement expression not to be COMPILE TIME CONSTANTS.

5. No two of the case constant expressions associated with a switch statement may have the same value.

6. At most one default label may be associated with the same switch statement.
7. Default clause is not compulsory in switch consturt.
---------------------------

enthuware test 1 -->
lots of confusion with inheritence - how interface, classes behaves with object and reference variable, considering polymorphism (override and overload of methods)

----------- Inheritance - Polymorphism (override, overload, hidden) ------------------
1. Interface variables are public static final implicitly, means constant and hidden. they can be called only using interface reference and not by any class who is implementing this interface.
2. In case of methods, an interface can have static, default or regular method with (public access modifier, this is implicit).
	--> static is again hidden method and can't be access directly but it can be accessed only using Interface name. example: Movable.test1();. means, you can't access it even using instance of derived class who is implementing it.
	--> default method can be empty or can give default implementation of a method. it can be overrided as well. it can also be access by interface reference variable in the class where class implemented an interface.
	--> regular method behaves also similar to default method. its an abstract method by default and can be overridden and accessed using reference variable of interface or derived class.

--------------------------------------

--> The order of keywords for a static import must be "import static ... ".
You can either import all the static members using import static java.lang.Integer.* or one specific member using import static java.lang.Integer.MAX_VALUE;
You must specify the full package name of the class that you are importing (just like the regular import statement). So, import static Integer.*; is wrong.
example:- import static java.lang.System.*; // valid (so that we can use out field of System,like this out.println("test"); directly.

--> The point to note here is that the j in for loop is different from the instance member j. The for loop j is inside a method as well as inside the for loop. Therefore, j++ occuring in the for loop doesn't affect the while loop. The for loop prints 1 2 3 4 5.
The while loop runs for the values 0 to 5 i.e. 6 iterations. Thus, 1 2 3 4 5 is printed 6 times. Note that after the end of the while loop the value of j is 6.

--> note, x is primitive int.You cannot call any methods on a primitive. so this.x.setInt(...) or this.y.setInt(...) don't make any sense.
Remember, a private valriable one class can't be accessed in another class by any means.

--> The return type should be same for overridden and overriding method, if return type is primitime type.
Note that when a method returns objects (as opposed to primitives, like in this question), the principle of covariant returns applies. Meaning, the overriding method is allowed to return a subclass of the return type defined in the overridden method. Thus, if a base class's method is: public A m(); then a subclass is free to override it with: public A1 m(); if A1 extends A.

--> Below are the rules to understand for any expression evaluation:
here, int i = 0; and The statement iA[i] = i = 30 ; will be processed as follows:
iA[i] = i = 30; => iA[0] = i = 30 ;  =>  i = 30; iA[0] = i ; =>   iA[0] = 30 ;

Here is what JLS says on this:
1 Evaluate Left-Hand Operand First  
2 Evaluate Operands before Operation  
3 Evaluation Respects Parentheses and Precedence  
4 Argument Lists are Evaluated Left-to-Right  

For Arrays: First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.


--> An important aspect of encapsulation is that other classes should not be able to modify the state fields of a class directly. Therefore, the data members should be private (or protected if you want to allow subclasses to inherit the field) and if the class wants to allow access to these fields, it should provide appropriate setters and getters with public access.

private ArrayList<Integer> scores;
Change getScores to return a copy of the scores list:
   public ArrayList<Integer> getScores(){ 
     return new ArrayList(scores); 
  }
If you return the same scores list, the caller would be able to add or remove elements from it, thereby rendering the average incorrect.
This can be prevented by returning a copy of the list.

--> nested if-else statements are very tricky. need to focus more on this. if there is any else statment (doesn't matter about its indentation in java), belongs to the most inner if statement. means, the inner if statement might conceivably own the else clause and outer most if doesn't have even any else clause. also, remember, there can't be 2 else associtaed with one if. its always if-else.

--> ****** very important ******** few exam question must be on this
--- Printing an Exception --> three ways to print an exception
    1. let Java print it out, 
    2. print just the message, or
    3. print where the stack trace comes from
  This example shows all three approaches:
      5: public static void main(String[] args) {
      6: try {
      7: hop();
      8: } catch (Exception e) {
      9: System.out.println(e); // Just the name of the exception class and the message is printed.
      10: System.out.println(e.getMessage()); // print just the message
      11: e.printStackTrace(); // print complete chain of the names of the methods called, along with the line numbers
      12: }
      13: }
      14: private static void hop() {
      15: throw new RuntimeException("cannot hop");
      16: }
    This code results in the following output:
	java.lang.RuntimeException: cannot hop  // Just the name of the exception class and the message is printed.
	cannot hop
	java.lang.RuntimeException: cannot hop //print complete chain of the names of the methods called, along with the line numbers
	at trycatch.Handling.hop(Handling.java:15)
	at trycatch.Handling.main(Handling.java:7)

--> Need to memorize few java rules:
while (false) { x=3; } is a compile-time error because the statement x=3; is not reachable;
Similarly, for( int i = 0; false; i++) x = 3; is also a compile time error because x= 3 is unreachable.

In if(false){ x=3; }, although the body of the condition is unreachable, this is not an error because the JLS explicitly defines this as an exception to the rule. It allows this construct to support optimizations through the conditional compilation. For example,

if(DEBUG){ System.out.println("beginning task 1"); } 
Here, the DEBUG variable can be set to false in the code while generating the production version of the class file, which will allow the compiler to optimize the code by removing the whole if statement entirely from the class file.

example:- 
if (false) { x=3; } // valid
for( int i = 0; i< 0; i++) x = 3; // valid

--> Note that it is OK to override a method by an abstract method.

--> few java Exception classes example:-
java.io.FileNotFoundException   / java.io.IOException
java.lang.OutOfMemoryError      /  java.lang.StackOverflowError
java.lang.SecurityException. 
This exception extends RuntimeException and is thrown by the security manager upon security violation. For example, when a java program runs in a sandbox (such as an applet) and it tries to use prohibited APIs such as File I/O, the security manager throws this exception.
Since this exception is explicitly thrown using the new keyword by a security manager class, it can be considered to be thrown by the application programmer.

--> Very important for exam:----------------- labeled break or continue statements ------------
you can assign label to any statment in java file. but when that label is used with break statment, then that break statment must be within the scope of label. else code won't compile.
example:-
void crazyLoop(){
   int c = 0;
   JACK: while (c < 8){
       JILL: System.out.println(c);
       if (c > 3) break JILL; else c++;
   }
}
here, Because break JILL; would be valid only when it is within the block of code under the scope of the label JILL. 
In this case, the scope of JILL extends only up till System.out.println(c); and break JILL; is out of the scope of the label.
Here, we need to understand that label is either declared for specific loop (while, do-while, for) or for specific individual statements. 

Remember that a labeled break or continue statement must always exist inside the loop where the label is declared. Here, if(j == 4) break POINT1; is a labelled break that is occurring in the second loop while the label POINT1 is declared for the first loop.

You can apply a label to any code block or a block level statement (such as a for statement) but not to declarations. For example: loopX : int i = 10;

Even if the break statment takes the control out of the try-catch-finally block, the finally clause will be executed. A break without a label breaks the current loop (i.e. no iterations any more) and a break with a label tries to pass the control to the given label.
'Tries to' means that if the break is in a try block and the try block has a finally clause associated with it then it will be executed.

------------------------------------
--> When you create an array of Objects ( here, Strings) all the elements are initialized to null. So in the line 3, null is assigned to myStr.
Note that. empty string is "" ( String str = ""; ) and is not same as null.

--> some Array vs Arraylist points
An ArrayList resized dynamically at run time as per the situation. An array cannot be resized once created. This reduces the amount of boiler plate code that is required to do the same task using an array.
Neither an ArrayList nor an array is thread safe. If you have multiple threads trying to add and remove elements from an ArrayList or an array, you have to write additional code to ensure thread safety.
arrays do not implement Collection interface. ArrayList does. This is actually an advantage of an ArrayList over an array.

--> a good question about how an expression can be evaluated with function and different operators
int s = 5;
s = s + s + mx(s) + ++s; // here value of s is assinged first to all the operands at a single strech, as you can see below
s = 5 + 5 + mx(5) + 6; // then the calculation started
s = 5 + 5+ 8 + 6;
s = 24;

------------------------
--> You need to remember the following points about Boolean:

1. Boolean class has two constructors - Boolean(String) and Boolean(boolean)
The String constructor allocates a Boolean object representing the value true if the string argument is not null and is equal, ignoring case, to the string "true". Otherwise, allocate a Boolean object representing the value false. Examples: new Boolean("True") produces a Boolean object that represents true. new Boolean("yes") produces a Boolean object that represents false.

The boolean constructor is self explanatory.

2. Boolean class has two static helper methods for creating booleans - parseBoolean and valueOf.
Boolean.parseBoolean(String ) method returns a primitive boolean and not a Boolean object (Note - Same is with the case with other parseXXX methods such as Integer.parseInt - they return primitives and not objects). The boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string "true". 

Boolean.valueOf(String ) and its overloaded Boolean.valueOf(boolean ) version, on the other hand, work similarly but return a reference to either Boolean.TRUE or Boolean.FALSE wrapper objects. Observe that they dont create a new Boolean object but just return the static constants TRUE or FALSE defined in Boolean class.

3. When you use the equality operator ( == ) with booleans, if exactly one of the operands is a Boolean wrapper, it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). If both are Boolean wrappers, then their references are compared just like in the case of other objects. Thus, new Boolean("true") == new Boolean("true") is false, but new Boolean("true") == Boolean.parseBoolean("true") is true.

-------------------------

--> imp points regarding for loop ---
 ehanced for loop Cannot use an existing/predefined variable in the variable declaration part, also you cannot declare same variable which you declared at class level. final is the only modifier (excluding annotations) that is allowed in the variable declaration part of for loop.
 example:- class A { 
 int i =0; int[][] intArr = {{0, 2, 5}}; 
 for (i : intArr[0]){} // invalid, enhanced for loop (means, enhanced for loop can't use same class variable)
 for (int j:intArr[0]){} // valid, enhanced for loop
 for (; i<5; i++){} // valid, regular for loop (means, regular for loop can use same class variable)
 for (int k; k<0; k++){} //invalid, k must be declared and initialzed as well, to use it inside for loop

--> The concept to understand here is as follows -
If the compiler can figure out that something can NEVER happen, then it flags an error. In this question, the compiler knows that ln, i or d can never point to the same object in any case because they are references to different classes of objects that have no relation ( superclass/subclass ) between themselves. Although, equals() method can be applied to any of them for comparision, as equals methods takes Objects as Aurgument.
example:-
Integer i = new Integer(42);
Long ln = new Long(42);
Double d = new Double(42.0);

--> classes that can't be inherited because those are final classes ---
String, StringBuilder, and StringBuffer - all are final classes.
1. Remember that wrapper classes for primitives (java.lang.Boolean, java.lang.Integer, java.lang.Long, java.lang.Short etc.) are also final and so they cannot be extended. 
2. java.lang.Number, however, is not final. Integer, Long, Double etc. extend Number.
3. java.lang.System is final as well.

---> need to memorize this point --
It is not required for a class to have a main method. The main method is required only if you want to execute that class directly from a command line.  Further, running from command line is not the only way to test a class.

--> Garbage collection.  All you need to know is: --------------------------
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();
----------------

-------- Order of Initialization ---->  *** Very imp (page 202)    
        1. If there is a superclass, initialize it first. 
        2. Static variable declarations and static initializers in the order they appear in the file.
        3. Instance variable declarations and instance initializers in the order they appear in the file.
        4. Any other statements that is making any changes to instance variable in the order they appear in the file.
        5. The constructor.
------------------------------------------------------	


enthuware Standard test 1 --> 
--> Trying to override a static method with a non-static method (and vice-versa) in a class or interface will result in a compilation error. Although,
You can, however, have a default method in a subinterface with the same signature as a static method of its super interface because a static method of an interface can only be called using that interface's name. 
Example:
interface I{
   public default void invalid(){ }
   public static void valid(){ } //Can be called only using I.valid();
}
interface I2 extends I{
   public static void invalid(){ } //WILL NOT COMPILE
   public default void valid(){ } //this is ok. 
}
-->  static methods can never be abstract (neither in an interface nor in a class).
-->  An interface can have a static method but the method must have a body.
-->  An interface method cannot be default and static at the same time because a default method is always an instance method.

--> Signature of equals method is : boolean equals(Object o); So it can take any object.
The equals methods of all wrapper classes first check if the two object are of same class or not. If not, they immediately return false. Hence it will print not equal.

--> checked exception must be declared or handled by all caller methods, in hirarchical way.
java.lang.Exception is a checked Exception. Which means, the method that throws this exception must declare it in the throws clause. Hence, yourMethod must declare throws Exception in its throws clause.
Change declaration of all the three method to include throws Exception or handle in catch block of method respectively.

--> Here, b refers to an object of class Beta so b.getH() will always call the overridden (subclass's method). However, the type of reference of b is Baap. so b.h will always refer to Baap's h.

Further, inside Beta's getH(), Beta's h will be accessed instead of Baap's h because you are accessing this.h ('this' is implicit) and the type of this is Beta.

--> Although generics are not included in this exam, some candidates have reported getting similar questions that incidently touch generic syntax but are not really about generics.

This question is based on your understand of is-a relationship. When class A extends or implements B directly or indirectly, you can say that A is-a B. Here, Car directly extends Vehicle and directly implements Drivable. Therefore, a Car is-a Vehicle and a Car is-a Drivable.
Similarly, an SUV is-a Car and since Car is-a Vehicle and is-a Drivable, SUV is also a Vehicle and a Drivable.

Now, the rule is that if you have a container that is meant to contain A, then you can add anything that is-a A to that container. For example, if you have ArrayList<Car>, you can add a SUV to it because an SUV is-a Car. But if you have ArrayList<SUV>, you cannot add a Car to it because a Car is not an SUV.

--> String[] sA = new String[1] { "aaa"}; // does not compile // Array can't declare and initialze at the same line.
Array size cannot be given here as the array is being initialized in the declaration.

--> Only java.lang package is imported automatically. All other packages including exception package must be imported explicitly.

--> n case of overriding, the return type of the overriding method must match exactly to the return type of the overridden method if the return type is a primitive.
(In case of objects, the return type of the overriding method may be a subclass of the return type of the overridden method.)

--> Lambda expression points to be noted:-
Predicate is typed to List (not ArrayList) in the checkList method, therefore, the parameter type in the lambda expression must also be List. It cannot be ArrayList.
The add method of ArrayList returns a boolean. Further, it returns true if the list is altered because of the call to add. In this case, al.add("hello") indeed alters the list because a new element is added to the list.

--> Compiler will complain that the method intValue() is not available in Object. This is because the . operator has more precedence than the cast operator. So you have to write it like this:
    int k = ((Integer) t).intValue()/9;
Now, since both the operands of / are ints, it is an integer division. This means the resulting value is truncated (and not rounded). Therefore, the above statement will print 11 and not 12.

--> 
