--> There are all primitive type wrapper class. no need to get confuse.
--> switch statement limitation --> it can't accept long, boolean, double and float value in its consturct aurgument.
--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class

------ instanceof operator ---- type operator ---
used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
  
--> an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method.

-----------------------------------------------------------------------
--> most imp points for JAVA Date-Time API:------------------------------
Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - 

1. They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date.

2. java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField.

3. LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate contains just the date information and no time information, LocalTime contains only time and no date, while LocalDateTime contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. 

These classes are immutable and have no public constructors. You create objects of these classes using their static factory methods such as of(...) and from(TemporalAccessor ).  For example, 
LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); or LocalDate ld = LocalDate.from(anotherDate); or LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM

Since you can't modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(...). For example, 
LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY));

4. Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc.  For example - 
        
LocalDate d1 = LocalDate.parse("2015-01-01", DateTimeFormatter.ISO_LOCAL_DATE);

The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn't directly cast the returned values to concrete classes like this - 
   LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"); //will compile but may or may not throw a ClassCastException at runtime.
You should do like this - 
   LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"));

5. Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds.

Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

Java 8 introduces a new package java.time to deal with dates. The old classes such as java.util.Date are not recommended anymore.

Briefly:
java.time Package: This is the base package of new Java Date Time API. All the commonly used classes such as LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration are part of this package. All of these classes are immutable and thread safe. 

java.time.format Package: This package contains classes used for formatting and parsing date time objects such as java.time.format.DateTimeFormatter.

(The following two are not important for the exam.)

java.time.zone Package: This package contains classes for supporting different time zones and their rules.

java.time.chrono Package: This package defines generic APIs for non ISO calendar systems. We can extend AbstractChronology class to create our own calendar system.
java.time.temporal Package: This package contains temporal objects and we can use it for find out specific date or time related to date/time object. For example, we can use these to find out the first or last day of the month. You can identify these methods easily because they always have format “withXXX”.
------------------------------------------------------

--> The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char, whose
values are 16-bit unsigned integers representing UTF-16 code units.
--> & can have integral as well as boolean operands.
unlike &&, & will not "short circuit" the expression if used on boolean parameters.
--> The modulus operator % can only be used with integer operands.
It can be used on floating points operands also. For example, 5.5 % 3 = 2.5
--> !, && and || operate only on booleans.
--> ~ Operates only on integral types

--> following are valid methods of String class:- trim, length, concate, and hashCode,
--> following are valid method for StringBuilder/StringBuffer --> reverse() 
(Note, reverse method is not available in String class)

----------------------------
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - 
interface Predicate<T> {
    boolean test(T t);
}

The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.
-------------------------------------------
private, protected and public can be applied to a nested class.

Although not too important for the exam, you should still know the following terminology: A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface.

synchronized keyword can never be applied to a class or non-primitive variables. It can only be applied to a method or a block.
final keyword can be applied to class, variable and methods.
final keyword when applied to a class means the class cannot be subclassed, when applied to a method means the method cannot be overridden (it can be overloaded though) and when applied to a variable means that the variable is a constant.
A final variable can be hidden in a subclass.

----------------------------
non-public class can't be accessed outside a package in which it is defined, even if it is explicitely imported. Because class itself is not accessible / visible. Only protected class can be accessed if you have import and inherite (extend) them and use it with child class object. 

--> You can't import classes from the default package. The only way to access classes in the default package is from another class in the default package. A class or interface that is defined in any other package can't access classes or interfaces defined in default package.

--> Also, remember, Java allows a class to only public or package private (default). there is no concept of class with private modifier unless it is a nested class.

--> Remember, when a char primitive data type used with arithmetic operators, its ASCII value is used, which is int value only. 

--> you can't assign a negative int value to a char data type without casting. (example, char ch = (char) -97;)
If you are using a variable in any specific statement that becomes undefined due to compile error than the statement which is using that variable will also through compile error because that variable is undefined for it.

--> Remember, if a method aurgument expecting a double or float, you can't pass int value in the method aurgument.
on the other side, if method aurgument is of type long, then you can pass int value to it.
--> you can define overloaded constructors or methods with different access modifiers.
Remember, a constructor don't have any return type. But a class can have a method name and signature same as constructor, only distinction would be return type of method.

--> you can't assign an Array of char to an Array of int data type.
Array and ArrayList are very specific to its datatype, means you can't pass any other data type values to it.
not even char or byte can compare with int and int can't be comapred with long type array. all are independent to specific type.

--> you can't initialize an array with new keyword and array default construtor like in general we do for all other class. Instead, Array is initialzed using new keyword followed by type of array. {(example:- new Array() not allowed), (but int arr[] = new int[5] is allowed)}
Also remember, you can't create an array like this "int arr[] = new int[]", means you must either give array dimensions or array initializer values. even creating empty array is legal, means Array of Zero length. 
like int arr[] = new int[5], or int arr[] = new int[] {5, 2}, or int arr[] = new int[] {}

--> Switch statment accepts variables of type String. and since an Arraylist can have String values, it can be passed to switch construct as well.
ArrayList clear() method is used to remove all elements of ArrayList.
ArrayList remove() method is used to remove specific element of ArrayList.
If you frequently add elements to ArrayList, its a good idea to create an ArrayList of large size.
Calling Clone() method on an ArrayList will create a separate reference variable that stored the same number of elements as the original ArrayList. But each individual ArrayList element will still refer to original object, means, ArrayList elements are not cloned.
An ArrayList can store any type of objects. Wrapper classes are created for ArrayList only.

--> The method contains() of ArrayList accepts an object and compares it with the actual values of the list. Means, it behaves very similar to equals() method, which checks objects actual value and not object itself.

--> format method of LocalDate / Time can be applied only on object of LocalDate / Time or DateTimeFormater object. not on any string or text value.
--> remember, while loop validation condition runs at the very end as well, to make sure its not validating to true and any evaluation at this step can also make some change to final result.
--> Case statment label requires a compile time constant variable/values. Even if you define a final variable, assigning a value to that variable in the next line, means after its declaration, java doesn't count it as compile time constant.
Remember, when you use "/" this division operator, the result of its evaluation is only division and not remainder. (for example, 10/3 = 3 as a result and remainder 3 will be discarded). Hence this can be used in case statmenent to compare value against int variable of switch statment.
--> Java performs integer calculations at compile time only, if there is no object for which value can be changed at run-time. 
Hence, if 2 case statement evaluate to same value then java throws a compile error.

--> you can't instantiate an interface but you can create a reference of an interface to access its variable and methods.
--> a method in an interface is implicitly (assumed to be) public. Hence, any class then implements this interface and its method should also be public.
--> The easiest way to identify the StackOverflowError is to find out the recursive call of method.

--> ArrayIndexOutOfBoundException and StringIndexOutOfBoundException is a derived (child) class of IndexOutOfBoundException. 
Always remember, sequence of catch block is important based on Exception. Catch block of derived class should always come first than catch block of base class. Else, code doesn't compile.

--> remember, return; statement is used to end the execution of method. but where we use it is also important.
In this case, guru() method is called inside a try block, when an error or exception occur in try block, java looks for catch block. It couldn't find in guru() method hence control goes to method() which is upper method and java looks for catch block in that, but found finally block. Hence, run the code for finally block and then throws error with JVM.
Note:- you can still catch an exception which was thrown using throw statement inside a method.

--> Runtime exception can be thrown without declaring them and exception methods can pass variable as an aurgument.
but checked exception either needs to be declared or handled.
Remember, you can even create an object of exception class like (new StackOverFlowErrorException()) and can use it as normal object.
Throwable is parent class of Exception class.

--> If a try block throw an exception and catch block handles it properly, then other catch block will not run, but if present finally block will run. Any statement after catch or finally block will execute as regular statement.


