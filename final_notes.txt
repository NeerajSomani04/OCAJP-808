--> There are all primitive type wrapper class. no need to get confuse.
--> switch statement limitation --> it can't accept long, boolean, double and float value in its consturct aurgument.
--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class

------ instanceof operator ---- type operator ---
used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
  
--> an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method.

-----------------------------------------------------------------------
--> most imp points for JAVA Date-Time API:------------------------------
Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - 

1. They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date.

2. java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField.

3. LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate contains just the date information and no time information, LocalTime contains only time and no date, while LocalDateTime contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. 

These classes are immutable and have no public constructors. You create objects of these classes using their static factory methods such as of(...) and from(TemporalAccessor ).  For example, 
LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); or LocalDate ld = LocalDate.from(anotherDate); or LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM

Since you can't modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(...). For example, 
LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY));

4. Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc.  For example - 
        
LocalDate d1 = LocalDate.parse("2015-01-01", DateTimeFormatter.ISO_LOCAL_DATE);

The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn't directly cast the returned values to concrete classes like this - 
   LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"); //will compile but may or may not throw a ClassCastException at runtime.
You should do like this - 
   LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"));

5. Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds.

Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

Java 8 introduces a new package java.time to deal with dates. The old classes such as java.util.Date are not recommended anymore.

Briefly:
java.time Package: This is the base package of new Java Date Time API. All the commonly used classes such as LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration are part of this package. All of these classes are immutable and thread safe. 

java.time.format Package: This package contains classes used for formatting and parsing date time objects such as java.time.format.DateTimeFormatter.

(The following two are not important for the exam.)

java.time.zone Package: This package contains classes for supporting different time zones and their rules.

java.time.chrono Package: This package defines generic APIs for non ISO calendar systems. We can extend AbstractChronology class to create our own calendar system.
java.time.temporal Package: This package contains temporal objects and we can use it for find out specific date or time related to date/time object. For example, we can use these to find out the first or last day of the month. You can identify these methods easily because they always have format “withXXX”.
------------------------------------------------------

--> The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char, whose
values are 16-bit unsigned integers representing UTF-16 code units.
--> & can have integral as well as boolean operands.
unlike &&, & will not "short circuit" the expression if used on boolean parameters.
--> The modulus operator % can only be used with integer operands.
It can be used on floating points operands also. For example, 5.5 % 3 = 2.5
--> !, && and || operate only on booleans.
--> ~ Operates only on integral types

--> following are valid methods of String class:- trim, length, concate, and hashCode,
--> following are valid method for StringBuilder/StringBuffer --> reverse() 
(Note, reverse method is not available in String class)

----------------------------
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - 
interface Predicate<T> {
    boolean test(T t);
}

The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.
-------------------------------------------
private, protected and public can be applied to a nested class.

Although not too important for the exam, you should still know the following terminology: A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface.

synchronized keyword can never be applied to a class or non-primitive variables. It can only be applied to a method or a block.
final keyword can be applied to class, variable and methods.
final keyword when applied to a class means the class cannot be subclassed, when applied to a method means the method cannot be overridden (it can be overloaded though) and when applied to a variable means that the variable is a constant.
A final variable can be hidden in a subclass.


