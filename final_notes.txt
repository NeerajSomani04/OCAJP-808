--> There are all primitive type wrapper class. no need to get confuse.
--> switch statement limitation --> it can't accept long, boolean, double and float value in its consturct aurgument.
--> Array.binarySearch(number, 2); -> used for binary search (if number not found then (negate the expected position of number and add -1)
--> Sorting for Array string type has specfic order --> first number, then uppercase then lowercase
--> Note --> if you try to unbox a null, you will get NullPointerException, but you can autobox or pass null without any issue
      3: List<Integer> heights = new ArrayList<>();
      4: heights.add(null); // this is legal, because a null reference can be assigned to any reference variable.
      5: int h = heights.get(0); // NullPointerException // because we try to unbox that null to an int primitive.
--> remove method in ArrayList that takes index value to remove element of List. Hence, be careful.
    example:-- 
    List<Integer> numbers = new ArrayList<>(); 
    numbers.add(1); // [1]
    numbers.add(2); // [1,2]
    numbers.remove(1); //[1]
    System.out.println(numbers); // [1], this will print 1. 
--> converting Array to List and vice versa -->
      Arrays.asList(array); // note, it returns fixed size list // here, any changes to list or Array will impact each other, as both pointing to same.
      list.toArray(); --> is normal fixed size array
--> asList() method --> takes varargs, which let you pass in an array or just type out the String values.
--> Sorting an ArrayList, using Collections.sort(numbers); // Collections is the helper class

------ instanceof operator ---- type operator ---
used to test whether the object is an instance of the specified type (class or subclass or interface).
It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.

--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
  
--> an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method.

--> Code that tries to access an uninitialized local variable won't compile.
--> each type of loop can accept single statement without curly braces but multiple statement should be inside curly braces.
--> In this case Laptop reference variable and life reference variable are referring to two different objects. Any changes on any specific  object will not impact each other.

--> A .java file must have only one public class or one public interface, and file name should be the same as public class or interface. A .java file can have multiple class or interfaces.
--> for an interface only public, default access modifier & abstract non-access modifier are permitted.
--> for a class only public, default access modifier, and abstract & final non-access modifier are permitted.

-----------------------------------------------------------------------
--> most imp points for JAVA Date-Time API:------------------------------
Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - 

1. They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date.

2. java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField.

3. LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate contains just the date information and no time information, LocalTime contains only time and no date, while LocalDateTime contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. 

These classes are immutable and have no public constructors. You can create objects of these classes using their static factory methods such as of(...) and from(TemporalAccessor ).  For example, 
LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); or LocalDate ld = LocalDate.from(anotherDate); or LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM

Since you can't modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(...). For example, 
LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY));

4. Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc.  For example - 
        
LocalDate d1 = LocalDate.parse("2015-01-01", DateTimeFormatter.ISO_LOCAL_DATE);

The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn't directly cast the returned values to concrete classes like this - 
   LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"); //will compile but may or may not throw a ClassCastException at runtime.
You should do like this - 
   LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse("2015-01-01"));

5. Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds.

Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

Java 8 introduces a new package java.time to deal with dates. The old classes such as java.util.Date are not recommended anymore.

Briefly:
java.time Package: This is the base package of new Java Date Time API. All the commonly used classes such as LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration are part of this package. All of these classes are immutable and thread safe. 

java.time.format Package: This package contains classes used for formatting and parsing date time objects such as java.time.format.DateTimeFormatter.

(The following two are not important for the exam.)

java.time.zone Package: This package contains classes for supporting different time zones and their rules.

java.time.chrono Package: This package defines generic APIs for non ISO calendar systems. We can extend AbstractChronology class to create our own calendar system.
java.time.temporal Package: This package contains temporal objects and we can use it for find out specific date or time related to date/time object. For example, we can use these to find out the first or last day of the month. You can identify these methods easily because they always have format “withXXX”.
------------------------------------------------------

--> The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char, whose
values are 16-bit unsigned integers representing UTF-16 code units.
--> & can have integral as well as boolean operands. (unlike &&), & will not "short circuit" the expression if used on boolean parameters. means it will evaluate both operands or both side expression.
--> The logical operators, (&), (|), and (^), evaluates both operands, but is similar as (&& or ||, respectively)
It may be applied to both numeric (known as bit-wise opertaor - not in OCA) and boolean (known as logical operators) data types.

--> The modulus operator % can only be used with integer operands. It can be used on floating points operands also. For example, 5.5 % 3 = 2.5
--> !, && and || operate only on booleans.
--> ~ Operates only on integral types

short-circuit operators --> 
&& --> if first expression is false then it won't evaluate second expression.
|| --> if first expression is true then it won't evaluate second expression.

--> following are valid methods of String class:- trim, length, concate, and hashCode,
--> following are valid method for StringBuilder/StringBuffer --> reverse() 
(Note, reverse method is not available in String class)

----------------------------
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - 
interface Predicate<T> {
    boolean test(T t);
}

provided by the standard java library in java.util.function package.
The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.

-------------------------------------------
private, protected and public can be applied to a nested class (not in OCA).A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface.

synchronized keyword can never be applied to a class or non-primitive variables. It can only be applied to a method or a block.
final keyword can be applied to class, variable and methods.
final keyword when applied to a class means the class cannot be subclassed, when applied to a method means the method cannot be overridden (it can be overloaded though) and when applied to a variable means that the variable is a constant.
A final variable can be hidden in a subclass.

--> native method cannot be abstract.
----------------------------
non-public class can't be accessed outside a package in which it is defined, even if it is explicitely imported. Because class itself is not accessible / visible. Only protected class can be accessed if you have import and inherite (extend) them and use it with child class object. 

--> You can't import classes from the default package. The only way to access classes in the default package is from another class in the default package. A class or interface that is defined in any other package can't access classes or interfaces defined in default package.

--> Also, remember, Java allows a class to only public or package private (default). there is no concept of class with private modifier unless it is a nested class.

--> Remember, when a char primitive data type used with arithmetic operators, its ASCII value is used, which is int value only. 

--> you can't assign a negative int value to a char data type without casting. (example, char ch = (char) -97;)
If you are using a variable in any specific statement that becomes undefined due to compile error than the statement which is using that variable will also through compile error because that variable is undefined for it.

---------------------- constructors and general methods -------------
--> Remember, if a method aurgument expecting a double or float, you can't pass int value in the method aurgument.
on the other side, if method aurgument is of type long, then you can pass int value to it.
--> you can define overloaded constructors or methods with different access modifiers.
Remember, a constructor don't have any return type. But a class can have a method name and signature same as constructor, only distinction would be return type of method.
--> A constructor can't be defined using a non-access modifiers like, final, abstract or static
--> A constructor can't be defined with return type
--> A constructor can be defined with any access modifier, like public, private, protected, and package private(default)
--> constructors can not be inherited.
--> The default constructor is provided by the compiler only when a class does not define ANY constructor explicitly. 
--> The access type of a default constructor (created by Java) is same as the access type of the class. Thus, if a class is public, the default constructor will be public.
--> A constructor is non-static, and so it can access directly both the static and non-static members of the class.
---------------------------------- 

--> you can't assign an Array of char to an Array of int data type.
Array and ArrayList are very specific to its datatype, means you can't pass any other data type values to it.
not even char or byte can compare with int and int can't be comapred with long type array. all are independent to specific type.
--> An array element can be assigned to null.

--> you can't initialize an array with new keyword and array default construtor like in general we do for all other class. Instead, Array is initialzed using new keyword followed by type of array. {(example:- new Array() not allowed), (but int arr[] = new int[5] is allowed)}
Also remember, you can't create an array like this "int arr[] = new int[]", means you must either give array dimensions or array initializer values. even creating empty array is legal, means Array of Zero length. 
like int arr[] = new int[5], or int arr[] = new int[] {5, 2}, or int arr[] = new int[] {} // all valid

--> An array declaration becomes invalid, when you specify the size of array within square bracket and declaring, instantiating and initializing an array at the single line of code.
example:-
int eArry5[] = new int[2] {10,20}; // this is invalid

--> Switch statment accepts variables of type String. and since an Arraylist can have String values, it can be passed to switch construct as well.
--> Switch statement can't accept boolean, long, double, and float primitive data type and its wrapper classes as an aurgument. 
--> Switch statement can accept only byte, short, char, int data type and its wrapper class. it can also accept String, and enum.

ArrayList clear() method is used to remove all elements of ArrayList.
ArrayList remove() method is used to remove specific element of ArrayList.
If you frequently add elements to ArrayList, its a good idea to create an ArrayList of large size.
Calling Clone() method on an ArrayList will create a separate reference variable that stored the same number of elements as the original ArrayList. But each individual ArrayList element will still refer to original object, means, ArrayList elements are not cloned.
An ArrayList can store any type of objects. Wrapper classes are created for ArrayList only.

--> The method contains() of ArrayList accepts an object and compares it with the actual values of the list. Means, it behaves very similar to equals() method, which checks objects actual value and not object itself.

-------------------------------------
--> format method of LocalDate / Time can be applied only on object of LocalDate / Time or DateTimeFormater object. not on any string or text value.
--> remember, while loop validation condition runs at the very end as well, to make sure its not validating to true and any evaluation at this step can also make some change to final result.
--> Case statment label requires a compile time constant variable/values. Even if you define a final variable, assigning a value to that variable in the next line, means after its declaration, java doesn't count it as compile time constant.
Remember, when you use "/" this division operator, the result of its evaluation is only division and not remainder. (for example, 10/3 = 3 as a result and remainder 3 will be discarded). Hence this can be used in case statmenent to compare value against int variable of switch statment.
--> Java performs integer calculations at compile time only, if there is no object for which value can be changed at run-time. 
Hence, if 2 case statement evaluate to same value then java throws a compile error.

--> you can't instantiate an interface but you can create a reference of an interface to access its variable and methods.
--> a method in an interface is implicitly (assumed to be) public. Hence, any class then implements this interface and its method should also be public.
--> The easiest way to identify the StackOverflowError is to find out the recursive call of method.

--> ArrayIndexOutOfBoundException and StringIndexOutOfBoundException is a derived (child) class of IndexOutOfBoundException. 
Always remember, sequence of catch block is important based on Exception. Catch block of derived class should always come first than catch block of base class. Else, code doesn't compile.

--> remember, return; statement is used to end the execution of method. but where we use it is also important.
In this case, guru() method is called inside a try block, when an error or exception occur in try block, java looks for catch block. It couldn't find in guru() method hence control goes to method() which is upper method and java looks for catch block in that, but found finally block. Hence, run the code for finally block and then throws error with JVM.
Note:- you can still catch an exception which was thrown using throw statement inside a method.

--> Runtime exception can be thrown without declaring them and exception methods can pass variable as an aurgument.
but checked exception either needs to be declared or handled.
Remember, you can even create an object of exception class like (new StackOverFlowErrorException()) and can use it as normal object.
Throwable is parent class of Exception class.

--> If a try block throw an exception and catch block handles it properly, then other catch block will not run, but if present finally block will run. Any statement after catch or finally block will execute as regular statement.
--> A finally block can't be placed before catch block.
--> finally is always executed (even if you throw an exception in try or catch) but this is the exception to the rule.
When you call System.exit(...); The JVM exits so there is no way to execute the finally block. 

--> If there is not catch block for a thrown exception then any uncaught exception will cause the JVM to kill the thread. means, Any remaining code of the method will not be executed.
--> The catch argument type declares the type of exception that the handler can handle and must be the name of a class that extends Throwable or Throwable itself.
--> A try without resources must have either a catch or a finally. It may have both as well.
--> A catch can catch multiple exceptions:
try{
}
catch(Exception1|Exception2|Exception3 e){  } 

--> Any class that extends Exception class becomes a checked exception.
--> Hence, when you call a method that throws a checked exception, you can either handle it using try-catch block or declare it to be thrown in caller method signature.

-->  "instanceof" is all smallcase letter operator to compare an object for its class instance.

---------- polymorphism (overloading and overridding), object vs reference variable ----------------------
--> A base (parent) class can use reference variables and objects of its derived (child) class. even as a method aurgument which is defined in base class.

--> A reference variable of Derived (Child) class can't be used to refer an object of base (parent) class.
example:- 
Dog dog = new Animal(); // does not compile, object of parent class and reference of child class not allowed.
Animal animal = new Lion(); // valid -  it will access all Animal class members
((Lion) animal).age; // valid, explicitly casting to child class to access child class members ( in this case age)
Lion lion = new Lion(); // valid, child class object and child class reference
example:- 
--> you can explicitely cast any object to an interface, even if class doesn't implement it. and the code will compile. but if the object's class doesn't implement interface, the code will throw ClassCaseException at runtime.
example:-
interface Jumpable {}
class Animal {}
class Lion extends Animal implements Jumpable {}
Jumpable var6 = (Jumpable)(new Animal()); // runtime exception

---> a protected member is accessible in the subclass only using a reference whose declared type is of the same subclass (or its subclass.). 
-------------
--> polymorphism (overloading and overridding), object vs reference variable 
Phone phone1 = new Phone(); // only phone members accessible, even child overridden method not accessible
// Tablet tablet1 =  new Phone(); // compile error -- explicit cast is needed (Tablet)
// Tablet tablet1 = (Tablet) new Phone(); // compile successfully but ClassCastException at runtime
Phone phone2 = new Tablet(); // only phone members accessible, child overridden method accessible
	// to access child members, need to cast explicitly //System.out.println(((Tablet)phone2).playmovie);
Tablet tablet2 = new Tablet(); // all parent and child members accessible as child inherit them

-----------------------------------------------------

--> --> remember below defaulty value for all primitive type --> 
--> char - \u0000 | byte,short,int - 0 | long - 0L | 
--> float - 0.0f | double - 0.0d | boolean - false | objects - null
--> but when these value passed to print method it will print without specific data type charachter (exmple, for float it will print 0.0, for long it will print 0, etc.)
--> The local variable (variables that are declared within a method) aren't initialzed with their default values. If you try to print the value of a local variable before initializing it, the code won't compile. 
--> On the other side, class and instance variable, initialize variable with default value.
--> Conversion from char to long does not need a cast. 
Conversion from byte to short does not need a cast.
Conversion from short to char needs a cast. The reverse is also true. Because their ranges are not compatible.
a float can hold any value of int hence conversion not needed. Note that opposite is not true because of loss of precision.
Conversion from byte, char or short to int, long or float does not need a cast. Because int, long or float are bigger that byte char or short.

int i = 10;
byte b = 20;
b = i;//will not compile because byte is smaller than int
b = (byte) i; //OK
Further, if you have a final variable and its value fits into a smaller type, then you can assign it without a cast because compiler already knows its value and realizes that it can fit into the smaller type. This is called implicit narrowing and is allowed between byte, int, char, and, short but not for long, float, and double.
final int k = 10;
b = k; //Okay because k is final and 10 fits into a byte
final float f = 10.0;//will not compile because 10.0 is a double even though the value 10.0 fits into a float
i = f;//will not compile.

--------------------

--> a static member can access only static members but instance member can access both static and non-static (instance) members.
example:- if a main method needs to access a variable directly it must be static.   code won't compile otherwise.

--> static method of a class are hidden methods
--> calling static method is tied to the type of the reference variable and doesn't depend on the type of the object that's assigned to the reference variable. The static method belongs to a class and not to its objects. means, if reference variable is of parent class the static method of parent class would be called. Not the static method of child (because it can't be overridden). if reference variable of child class is used, then it will call child class static method.
      --> --> there is one exception, since child class inherit all method of parent, if child class doesn't define static method then on child class reference variable call, parent method would be called, as this static method of parent is now became a member of child class as well.

---> --> concept, if you modify the state of the loop variable, the modified object state will be reflected in the array. but if you assign a new object to the loop variable, it won't be reflected in the list or the array that's being iterated. you can compare this behavior of the enhanced for loop variable with the behavior of object references passed as arguments to a method.

--> --> Substring method of String class can't accept negative value. (for example: str.substring(2, -1) will throw runtime exception).
--> its important to remember which string method takes what type of arguments, for example, 
method "indexOf" can accept both String and char values.
method startsWith and endsWith can accept only String values. Can't accept char value.
method charAt can accept only method aurgument of type int. but remember, since java stored char values as unsigned integer values, its possible to pass char values as well in this method.
example:- 
String te = "12345";
System.out.println(te.charAt('3')); // in this case it will throw exception StringIndexOutOfBoundsException, because charachter '3' is equal to (51) in unsigned integer value.
System.out.println(te.charAt(3)); // this will compile successfully and print 4
--> StringBuilder default object capacity is 16 char. (StringBuilder sb1 = new StringBuilder();)
--------------------------------
--> --> When an object reference is marked as null, the object is marked for garbage collection. But you can't be sure exactly when a garbage collector will kick in to garbage collect the objects. A garbage collector is low-priority thread, its execution depends on OS> you can never be sure about which object have been garbage collected. you can only be sure about how many objects are eligible for garbage collection.

--> --> remember, equals method is a public method defined in java.lang.Object class, which is inherited by all classes. but default implementation of equals method is to compare the object reference pointing to same object, then return TRUE else FALSE. Any class can override this method to implement other logic. Here, no override happneded.
--> Need to check in general which classes overrides equals() method. 

--> --> There is no concat method in StringBuilder. There is append method in StringBuilder to append any string.
--> Also, insert method can be used to insert char, number, or String at any specified position of StringBuilder.

------------ break and continue statements -------------
--> break; statement breaks the execution of current loop. means, if you have a loop that should execute from 0 to 9 and you hit break; statement at 5 position then loop will not run for any value after 5, means from 6 to 9.
--> break statement are valid in iteration of loops (for, do, while) and in switch statement but not in if-else statement.
--> continue; statment, if you hit continue statment at 5 position, it will stop the current execution but continue run of loop from 6 to 9 value iteration.
--> continue; statement are valid in iteration of loops only (for, do, while) but invalid in switch or if-else statement.

-------------------------------------------------------------
--> every object operations should be assigned to reference variable. if you don't assign object to reference variable, it is not stored and become eligible for garbage collection.

--> The underscore can't be placed in between (0_x or 0_b) or even just after the initials (0b_10 or 0x_25). only exception it can be placed after first 0 (ex:- 0_1010_11). For hexaDecimal values the letter can be till f or F only, G and further is not allowed.

--> --> An abstract method must have the abstract keyword and must not have a method body i.e. { }.

--> variable types in a class ----
"class level" means static fields and they can be accessed from anywhere (i.e. static as well as non-static methods) in the class (and from outside the class depending on their accessibility).
"instance level" means the instance fields and they can be accessed only from instance methods in the class.
local variables are basically defined within a method and it must be initailized before use, else code won't compile.

--> correct order of restrictiveness for access modifiers...
public < protected < package (i.e. no modifier) < private
--> Members with default accessibility are only accessible within the class itself and from classes in the same package.
Protected members are in addition accessible from subclasses. Members with private accessibility are only accessible
within the class itself.

--> To call myMethod(int m, Object p, double d), you must pass exactly three parameters. If you try to pass less (or more) number of parameters, the code will not compile. Note that method parameters are not assigned default values.
It is possible to declare a method that can take variable number of parameters. For example: 
public static void someMethod(Object... params){
        System.out.println(params.length); }
You can call this method by passing any number of parameters. In this case, calling someMethod() without any parameter will print 0. i.e. the length of params array will be 0. params will NOT be null.

--> The visibility of the class is not limited by the visibility of its members. A class with all the members declared private can still be declared public or a class having all public members may be declared private.

--> Note that calling super(); will not always work because if the super class has defined a constructor with arguments and has not defined a no args constructor then no args constructor will not be provided by the compiler. It is provided only to the class that does not define ANY constructor explicitly.

--> Fields in an interface are implicitly public, static and final. Although you can put these words in the interface definition but it is not a good practice to do so.

--> You cannot apply any modifier except final to a local variable. i.e. you cannot make them transient, volatile, static, public, and private.
But you can apply access modifiers (public private and protected) and final, transient, volatile, static to instance variables.
You cannot apply native and synchronized to any kind of variable.

------------- switch statement basics ----
You should remember the following rules for a switch statement:

1. Only String, byte, char, short, int, and enum values can be used as types of a switch variable. (String is allowed since Java 7.) Wrapper classes Byte, Character, Short, and Integer are allowed as well.

2. The case constants must be assignable to the switch variable. For example, if your switch variable is of class String, your case labels must use Strings as well.

3. The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char's range is from 0 to 65535. Similarly, the following will not compile because 300 cannot be assigned to 'by', which can only hold values from -128 to 127.
byte by = 10;
switch(by){
    case 200 :  //some code;
    case 300 :  //some code;
}

4.  All case labels should be COMPILE TIME CONSTANTS. 

5. No two of the case constant expressions associated with a switch statement may have the same value.

6. At most one default label may be associated with the same switch statement.
7. Default clause is not compulsory in switch consturt.
---------------------------

